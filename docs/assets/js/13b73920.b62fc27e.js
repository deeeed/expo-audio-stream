"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[7240],{8883:(e,i,r)=>{r.r(i),r.d(i,{assets:()=>l,contentTitle:()=>d,default:()=>m,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"api-reference/audio-processing/trim-audio","title":"trimAudio","description":"The trimAudio function allows you to trim audio files with precision, supporting multiple segments and various output formats. This is useful for removing silence, extracting specific parts of recordings, or compiling multiple segments into a single audio file.","source":"@site/docs/api-reference/audio-processing/trim-audio.md","sourceDirName":"api-reference/audio-processing","slug":"/api-reference/audio-processing/trim-audio","permalink":"/expo-audio-stream/docs/api-reference/audio-processing/trim-audio","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"trim-audio","title":"trimAudio","sidebar_label":"trimAudio"},"sidebar":"tutorialSidebar","previous":{"title":"extractMelSpectrogram","permalink":"/expo-audio-stream/docs/api-reference/audio-processing/extract-mel-spectrogram"},"next":{"title":"README","permalink":"/expo-audio-stream/docs/api-reference/API/"}}');var t=r(4848),s=r(8453);const o={id:"trim-audio",title:"trimAudio",sidebar_label:"trimAudio"},d="trimAudio",l={},c=[{value:"Syntax",id:"syntax",level:2},{value:"Parameters",id:"parameters",level:2},{value:"OutputFormatOptions",id:"outputformatoptions",level:3},{value:"Return Value",id:"return-value",level:2},{value:"Examples",id:"examples",level:2},{value:"Basic Trimming",id:"basic-trimming",level:3},{value:"Multiple Segments",id:"multiple-segments",level:3},{value:"Removing Segments",id:"removing-segments",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2}];function a(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"trimaudio",children:"trimAudio"})}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"trimAudio"})," function allows you to trim audio files with precision, supporting multiple segments and various output formats. This is useful for removing silence, extracting specific parts of recordings, or compiling multiple segments into a single audio file."]}),"\n",(0,t.jsx)(i.h2,{id:"syntax",children:"Syntax"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-typescript",children:"async function trimAudio(options: TrimAudioOptions): Promise<string>\n"})}),"\n",(0,t.jsx)(i.h2,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsx)(i.p,{children:"The function accepts a single object with the following properties:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Property"}),(0,t.jsx)(i.th,{children:"Type"}),(0,t.jsx)(i.th,{children:"Required"}),(0,t.jsx)(i.th,{children:"Default"}),(0,t.jsx)(i.th,{children:"Description"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"fileUri"})}),(0,t.jsx)(i.td,{children:"string"}),(0,t.jsx)(i.td,{children:"Yes"}),(0,t.jsx)(i.td,{children:"-"}),(0,t.jsx)(i.td,{children:"Path to the audio file to trim"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"startTimeMs"})}),(0,t.jsx)(i.td,{children:"number"}),(0,t.jsx)(i.td,{children:"No*"}),(0,t.jsx)(i.td,{children:"-"}),(0,t.jsx)(i.td,{children:"Start time in milliseconds (for single segment mode)"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"endTimeMs"})}),(0,t.jsx)(i.td,{children:"number"}),(0,t.jsx)(i.td,{children:"No*"}),(0,t.jsx)(i.td,{children:"-"}),(0,t.jsx)(i.td,{children:"End time in milliseconds (for single segment mode)"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"mode"})}),(0,t.jsx)(i.td,{children:"'keep' | 'remove'"}),(0,t.jsx)(i.td,{children:"No"}),(0,t.jsx)(i.td,{children:"'keep'"}),(0,t.jsx)(i.td,{children:"Whether to keep or remove the specified ranges"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"ranges"})}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"Array<{startTimeMs: number, endTimeMs: number}>"})}),(0,t.jsx)(i.td,{children:"No*"}),(0,t.jsx)(i.td,{children:"-"}),(0,t.jsx)(i.td,{children:"Array of time ranges (for multi-segment mode)"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"outputFormat"})}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"OutputFormatOptions"})}),(0,t.jsx)(i.td,{children:"No"}),(0,t.jsx)(i.td,{children:"See below"}),(0,t.jsx)(i.td,{children:"Output format configuration"})]})]})]}),"\n",(0,t.jsxs)(i.p,{children:["* Either ",(0,t.jsx)(i.code,{children:"startTimeMs"}),"/",(0,t.jsx)(i.code,{children:"endTimeMs"})," pair or ",(0,t.jsx)(i.code,{children:"ranges"})," must be provided"]}),"\n",(0,t.jsx)(i.h3,{id:"outputformatoptions",children:"OutputFormatOptions"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Property"}),(0,t.jsx)(i.th,{children:"Type"}),(0,t.jsx)(i.th,{children:"Required"}),(0,t.jsx)(i.th,{children:"Default"}),(0,t.jsx)(i.th,{children:"Description"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"format"})}),(0,t.jsx)(i.td,{children:"'wav' | 'mp3' | 'aac' | 'opus'"}),(0,t.jsx)(i.td,{children:"No"}),(0,t.jsx)(i.td,{children:"'wav'"}),(0,t.jsx)(i.td,{children:"Output audio format"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"bitrate"})}),(0,t.jsx)(i.td,{children:"number"}),(0,t.jsx)(i.td,{children:"No"}),(0,t.jsx)(i.td,{children:"-"}),(0,t.jsx)(i.td,{children:"Bitrate for compressed formats (in kbps)"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"quality"})}),(0,t.jsx)(i.td,{children:"'low' | 'medium' | 'high'"}),(0,t.jsx)(i.td,{children:"No"}),(0,t.jsx)(i.td,{children:"'medium'"}),(0,t.jsx)(i.td,{children:"Quality preset for compressed formats"})]})]})]}),"\n",(0,t.jsxs)(i.p,{children:["Default value for ",(0,t.jsx)(i.code,{children:"outputFormat"})," is ",(0,t.jsx)(i.code,{children:"{ format: 'wav' }"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"return-value",children:"Return Value"}),"\n",(0,t.jsx)(i.p,{children:"The function returns a Promise that resolves to a string containing the URI of the trimmed audio file."}),"\n",(0,t.jsx)(i.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(i.h3,{id:"basic-trimming",children:"Basic Trimming"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-typescript",children:"import { trimAudio } from '@siteed/expo-audio-studio';\n\nasync function trimAudioSegment() {\n  try {\n    // Trim audio from 1 second to 5 seconds\n    const trimmedAudioUri = await trimAudio({\n      fileUri: 'path/to/recording.wav',\n      startTimeMs: 1000,\n      endTimeMs: 5000,\n      outputFormat: { format: 'wav' }\n    });\n    \n    console.log(`Trimmed audio saved to: ${trimmedAudioUri}`);\n    return trimmedAudioUri;\n  } catch (error) {\n    console.error('Error trimming audio:', error);\n    throw error;\n  }\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"multiple-segments",children:"Multiple Segments"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-typescript",children:"import { trimAudio } from '@siteed/expo-audio-studio';\n\nasync function extractMultipleSegments() {\n  try {\n    // Extract and combine two segments from the audio file\n    const compiledAudioUri = await trimAudio({\n      fileUri: 'path/to/recording.wav',\n      mode: 'keep',\n      ranges: [\n        { startTimeMs: 1000, endTimeMs: 5000 },\n        { startTimeMs: 10000, endTimeMs: 15000 }\n      ],\n      outputFormat: { format: 'mp3', quality: 'high' }\n    });\n    \n    console.log(`Compiled audio saved to: ${compiledAudioUri}`);\n    return compiledAudioUri;\n  } catch (error) {\n    console.error('Error extracting audio segments:', error);\n    throw error;\n  }\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"removing-segments",children:"Removing Segments"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-typescript",children:"import { trimAudio } from '@siteed/expo-audio-studio';\n\nasync function removeSilenceOrNoise() {\n  try {\n    // Remove specific segments (e.g., silence or noise) from the audio\n    const cleanedAudioUri = await trimAudio({\n      fileUri: 'path/to/recording.wav',\n      mode: 'remove',\n      ranges: [\n        { startTimeMs: 2000, endTimeMs: 3000 },  // Remove silence\n        { startTimeMs: 7000, endTimeMs: 8500 }   // Remove noise\n      ],\n      outputFormat: { format: 'aac', bitrate: 128 }\n    });\n    \n    console.log(`Cleaned audio saved to: ${cleanedAudioUri}`);\n    return cleanedAudioUri;\n  } catch (error) {\n    console.error('Error removing audio segments:', error);\n    throw error;\n  }\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Content Editing"}),": Extract the most important parts of a recording"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Silence Removal"}),": Remove silent segments from recordings"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Compilation"}),": Combine multiple segments into a single audio file"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Noise Removal"}),": Remove sections containing unwanted noise"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Audio Clipping"}),": Create short clips from longer recordings"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Processing large audio files may take longer, especially when converting formats"}),"\n",(0,t.jsx)(i.li,{children:"When possible, use the same output format as the input to avoid transcoding overhead"}),"\n",(0,t.jsxs)(i.li,{children:["For multiple small segments, it's more efficient to process them in a single operation using the ",(0,t.jsx)(i.code,{children:"ranges"})," parameter rather than making multiple calls"]}),"\n",(0,t.jsx)(i.li,{children:"The function is optimized to minimize memory usage even for large files"}),"\n"]})]})}function m(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,i,r)=>{r.d(i,{R:()=>o,x:()=>d});var n=r(6540);const t={},s=n.createContext(t);function o(e){const i=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);