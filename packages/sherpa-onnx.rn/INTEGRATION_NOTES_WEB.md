# Sherpa-ONNX WebAssembly (WASM) API: React Native Integration Guide

## 1. Overview and Challenges

The Sherpa-ONNX library provides powerful speech processing capabilities through WebAssembly binaries. Integrating these capabilities into React Native Web presents several architectural challenges that this guide addresses.

### 1.1 WebAssembly Integration Complexity

React Native's integration with web code requires:
- JavaScript → React Native Web → Browser APIs → WebAssembly → C/C++ Library

This creates integration challenges:
- Loading and initializing WebAssembly modules
- Handling model files efficiently
- Managing memory across the JavaScript-WASM boundary
- Providing a consistent API with native platforms

### 1.2 Specific Technical Challenges

1. **WASM Module Distribution**
   - Each capability (TTS, ASR, etc.) is currently built as a separate WASM module
   - Separate `.js`, `.wasm`, and `.data` files must be managed for each module
   - The `.data` files contain preloaded assets (models) and can be large

2. **Model Loading Approaches**
   - **Preloaded assets**: Models bundled in the `.data` file during build
   - **Dynamic loading**: Loading models at runtime from URLs or file system
   - **Virtual filesystem**: Writing model files to WASM's virtual filesystem

3. **Memory Management**
   - WebAssembly has its own memory space
   - Data must be copied between JavaScript and WASM memory
   - Large audio samples and model files require careful memory handling

4. **API Consistency**
   - The web implementation should match the native API as closely as possible
   - All platforms should share a common TypeScript interface

## 2. Build System and Module Structure

### 2.1 Current Build Structure

```
packages/sherpa-onnx.rn/
├── build-sherpa-wasm.sh              # Main build script for WASM modules
├── third_party/sherpa-onnx/          # Original Sherpa-ONNX repository
│   ├── wasm/                         # WASM-specific code
│   │   ├── tts/                      # TTS implementation for WASM
│   │   ├── asr/                      # ASR implementation for WASM
│   │   └── ...                       # Other modules
│   ├── build-wasm-simd-tts.sh        # Module-specific build scripts
│   ├── build-wasm-simd-asr.sh
│   └── ...
├── prebuilt/                         # Build output directory
│   ├── web/                          # WASM build outputs
│   │   ├── tts/                      # TTS module files
│   │   │   ├── sherpa-onnx-wasm-main-tts.js    # WASM glue code 
│   │   │   ├── sherpa-onnx-wasm-main-tts.wasm  # WASM binary
│   │   │   ├── sherpa-onnx-wasm-main-tts.data  # Preloaded assets
│   │   │   ├── sherpa-onnx-tts.js              # JavaScript wrapper
│   │   │   └── ...
│   │   ├── asr/                      # ASR module files
│   │   └── ...
└── src/
    ├── WebSherpaOnnxImpl.ts          # Web implementation of the API
    └── SherpaOnnxAPI.ts              # Unified API across platforms
```

### 2.2 Output File Explanation

Each WASM module produces several files:

- **`.js`** - JavaScript "glue code" generated by Emscripten
  - Provides low-level functions to interact with the WASM module
  - Handles memory allocation and string conversion
  - Loads the `.wasm` and `.data` files

- **`.wasm`** - WebAssembly binary
  - Compiled C/C++ code
  - Contains exported functions (defined in CMakeLists.txt)
  - Provides the core functionality

- **`.data`** - Preloaded assets package
  - Contains models, configuration files, and other assets
  - Loaded by the glue code at runtime
  - Can be replaced or customized without rebuilding the WASM binary

- **JavaScript wrapper** (`sherpa-onnx-tts.js`, etc.)
  - High-level JavaScript API
  - Simplifies interaction with the WASM module
  - Handles configuration and data conversion

## 3. Integration Approaches

### 3.1 Current Approach: Separate Modules

The current implementation builds each capability (TTS, ASR, etc.) as a separate WASM module with:
- Separate build process
- Separate output files
- Separate model loading

Advantages:
- Smaller individual modules
- Only load what you need
- Can update modules independently

Disadvantages:
- Duplication of common code
- Multiple loading processes
- Inconsistent API

### 3.2 Unified Approach: Combined Module

A unified approach would build a single WASM module that includes multiple capabilities:

```bash
# Combined build command
cmake \
  -DSHERPA_ONNX_ENABLE_WASM=ON \
  -DSHERPA_ONNX_ENABLE_WASM_TTS=ON \
  -DSHERPA_ONNX_ENABLE_WASM_ASR=ON \
  -DSHERPA_ONNX_ENABLE_WASM_AUDIO_TAGGING=ON \
  ...
```

This would produce a single set of output files with all capabilities.

Advantages:
- Consistent API across capabilities
- Single loading process
- Shared common code

Disadvantages:
- Larger WASM binary
- All capabilities loaded even if not needed

### 3.3 Model Loading Approaches

There are three main approaches to loading models:

1. **Prebuilt in .data file** (current approach)
   - Models bundled during build
   - No additional loading required
   - Limited flexibility

2. **Virtual filesystem**
   - Load models from URLs at runtime
   - Write to WASM's virtual filesystem
   - Use file paths as in native code
   ```javascript
   // Example
   async function loadModelToVirtualFS(url, path) {
     const response = await fetch(url);
     const arrayBuffer = await response.arrayBuffer();
     const data = new Uint8Array(arrayBuffer);
     FS.writeFile(path, data);
     return path;
   }
   ```

3. **Direct memory approach**
   - Load models directly into WASM memory
   - Pass pointers to the C++ code
   - Requires changes to the C++ API
   ```javascript
   // Example (conceptual)
   async function loadModelToMemory(url) {
     const response = await fetch(url);
     const arrayBuffer = await response.arrayBuffer();
     const ptr = Module._malloc(arrayBuffer.byteLength);
     Module.HEAPU8.set(new Uint8Array(arrayBuffer), ptr);
     return { ptr, size: arrayBuffer.byteLength };
   }
   ```

## 4. Implementation Guide

### 4.1 Recommended Approach

Based on the analysis, we recommend:

1. **Create a unified WASM build** that includes all capabilities
2. **Use the virtual filesystem approach** for model loading
3. **Keep separate .data files** for default models

This provides the best balance of flexibility and ease of implementation.

### 4.2 Implementation Steps

1. **Create a combined build script**:
   ```bash
   # In build-sherpa-wasm.sh
   function build_combined_module() {
     # Similar to existing build_module function but with all capabilities enabled
     cmake \
       -DSHERPA_ONNX_ENABLE_WASM=ON \
       -DSHERPA_ONNX_ENABLE_WASM_TTS=ON \
       -DSHERPA_ONNX_ENABLE_WASM_ASR=ON \
       -DSHERPA_ONNX_ENABLE_WASM_AUDIO_TAGGING=ON \
       ...
   }
   ```

2. **Create a combined CMakeLists.txt**:
   - Merge the exported functions from all module CMakeLists.txt files
   - Set appropriate memory settings for all capabilities
   - Add additional exported functions for virtual filesystem operations

3. **Update WebSherpaOnnxImpl.ts**:
   - Add support for all capabilities
   - Implement the virtual filesystem approach for model loading
   - Create a unified API that matches the native implementations

4. **Create separate .data files**:
   - Build separate .data files for different model sets
   - Allow runtime selection of which .data file to load

### 4.3 Sample Code for Virtual Filesystem Approach

```typescript
// In WebSherpaOnnxImpl.ts
async initTts(config: TtsModelConfig): Promise<TtsInitResult> {
  try {
    // Load the WASM module if not already loaded
    this.module = await loadSherpaOnnxWasm();
    
    // If model paths are URLs, download and write to virtual filesystem
    if (config.modelFile.startsWith('http')) {
      const modelPath = '/models/tts/model.onnx';
      await this.loadFileToVirtualFS(config.modelFile, modelPath);
      config.modelFile = modelPath;
    }
    
    if (config.tokensFile.startsWith('http')) {
      const tokensPath = '/models/tts/tokens.txt';
      await this.loadFileToVirtualFS(config.tokensFile, tokensPath);
      config.tokensFile = tokensPath;
    }
    
    // Initialize TTS with the file paths in virtual FS
    this.tts = window.createOfflineTts(this.module, {
      offlineTtsVitsModelConfig: {
        model: config.modelFile,
        tokens: config.tokensFile,
        // Other config options
      }
    });
    
    // Rest of initialization
    // ...
  } catch (error) {
    // Error handling
  }
}

// Helper method to load a file to virtual filesystem
private async loadFileToVirtualFS(url: string, path: string): Promise<void> {
  const response = await fetch(url);
  const arrayBuffer = await response.arrayBuffer();
  const dirPath = path.substring(0, path.lastIndexOf('/'));
  
  try {
    // Create directory if it doesn't exist
    this.module.FS.mkdir(dirPath, 0o777);
  } catch (e) {
    // Directory may already exist, that's fine
  }
  
  // Write file
  this.module.FS.writeFile(path, new Uint8Array(arrayBuffer));
}
```

## 5. Common Issues and Troubleshooting

### 5.1 Memory Management

WebAssembly memory management requires careful attention:

- **Always free allocated memory**:
  ```javascript
  const ptr = this.module._malloc(size);
  try {
    // Use the memory
  } finally {
    this.module._free(ptr);
  }
  ```

- **Watch for large allocations**:
  - WebAssembly has a limited memory space
  - Audio data can be large, especially for ASR
  - Consider processing in chunks for long audio

### 5.2 Cross-Origin Restrictions

When loading models or other resources:

- Ensure proper CORS headers on server
- Consider bundling essential models with your application
- Use relative URLs where possible

### 5.3 Module Loading Issues

If WASM modules fail to load:

- Check for console errors related to missing files
- Verify that the .wasm and .data files are accessible
- Ensure the paths in loadSherpaOnnxWasm() are correct

### 5.4 Debugging WASM

To debug WebAssembly:

- Enable Emscripten's debug output in the build:
  ```
  -s ASSERTIONS=1 -s SAFE_HEAP=1
  ```
  
- Use the browser's developer tools to:
  - Monitor WebAssembly memory
  - Track network requests for .wasm and .data files
  - Debug the JavaScript glue code

## 6. Performance Considerations

### 6.1 Initial Load Time

WebAssembly modules can be large and impact page load:

- Consider lazy loading the WASM module
- Show a loading indicator during initialization
- Use a web worker for non-UI blocking initialization

### 6.2 Runtime Performance

WebAssembly performance considerations:

- TTS and ASR are computationally intensive
- Process audio in a web worker if possible
- Monitor memory usage for large audio files
- Consider smaller models for mobile web

## 7. Update Process for Future Versions

When a new version of Sherpa-ONNX is released:

1. Update the Sherpa-ONNX repository reference
2. Rebuild the WASM modules with the new source
3. Update any changed APIs in WebSherpaOnnxImpl.ts
4. Test thoroughly with various model configurations

Maintain backward compatibility where possible to avoid breaking changes.
