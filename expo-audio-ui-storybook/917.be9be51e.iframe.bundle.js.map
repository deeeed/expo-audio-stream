{"version":3,"file":"917.be9be51e.iframe.bundle.js","mappings":";;;;;;AA0iBA;AA+WA;;;;;AAKA;AC4YA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;AAGA","sources":["webpack://@siteed/expo-audio-ui/./node_modules/storybook/dist/_browser-chunks/chunk-2N4WE3KZ.js","webpack://@siteed/expo-audio-ui/./node_modules/storybook/dist/csf/index.js"],"sourcesContent":["import {\n  isTestEnvironment,\n  pauseAnimations,\n  waitForAnimations\n} from \"./chunk-MEXTPDJG.js\";\nimport {\n  Tag\n} from \"./chunk-AFVOZMXQ.js\";\nimport {\n  require_main\n} from \"./chunk-XLJZ7AOP.js\";\nimport {\n  SNIPPET_RENDERED,\n  combineParameters\n} from \"./chunk-SI6AKD4S.js\";\nimport {\n  isEqual\n} from \"./chunk-IYCKG66Y.js\";\nimport {\n  invariant\n} from \"./chunk-IWQGIXJS.js\";\nimport {\n  require_ansi_to_html\n} from \"./chunk-V2VKKSMQ.js\";\nimport {\n  mapValues,\n  pickBy\n} from \"./chunk-YK43Z22A.js\";\nimport {\n  isPlainObject\n} from \"./chunk-LCHBOIHN.js\";\nimport {\n  require_memoizerific\n} from \"./chunk-ZCFV7BZB.js\";\nimport {\n  dedent\n} from \"./chunk-3LY4VQVK.js\";\nimport {\n  __toESM\n} from \"./chunk-A242L54C.js\";\n\n// src/preview-api/modules/addons/main.ts\nimport { global } from \"@storybook/global\";\n\n// src/preview-api/modules/addons/storybook-channel-mock.ts\nimport { Channel } from \"storybook/internal/channels\";\nfunction mockChannel() {\n  let transport = {\n    setHandler: () => {\n    },\n    send: () => {\n    }\n  };\n  return new Channel({ transport });\n}\n\n// src/preview-api/modules/addons/main.ts\nvar AddonStore = class {\n  constructor() {\n    this.getChannel = () => {\n      if (!this.channel) {\n        let channel = mockChannel();\n        return this.setChannel(channel), channel;\n      }\n      return this.channel;\n    };\n    this.ready = () => this.promise;\n    this.hasChannel = () => !!this.channel;\n    this.setChannel = (channel) => {\n      this.channel = channel, this.resolve();\n    };\n    this.promise = new Promise((res) => {\n      this.resolve = () => res(this.getChannel());\n    });\n  }\n}, KEY = \"__STORYBOOK_ADDONS_PREVIEW\";\nfunction getAddonsStore() {\n  return global[KEY] || (global[KEY] = new AddonStore()), global[KEY];\n}\nvar addons = getAddonsStore();\n\n// src/preview-api/modules/addons/hooks.ts\nimport { logger } from \"storybook/internal/client-logger\";\nimport {\n  FORCE_RE_RENDER,\n  RESET_STORY_ARGS,\n  STORY_RENDERED,\n  UPDATE_GLOBALS,\n  UPDATE_STORY_ARGS\n} from \"storybook/internal/core-events\";\nimport { global as global2 } from \"@storybook/global\";\nvar HooksContext = class {\n  constructor() {\n    this.hookListsMap = void 0;\n    this.mountedDecorators = void 0;\n    this.prevMountedDecorators = void 0;\n    this.currentHooks = void 0;\n    this.nextHookIndex = void 0;\n    this.currentPhase = void 0;\n    this.currentEffects = void 0;\n    this.prevEffects = void 0;\n    this.currentDecoratorName = void 0;\n    this.hasUpdates = void 0;\n    this.currentContext = void 0;\n    this.renderListener = (storyId) => {\n      storyId === this.currentContext?.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());\n    };\n    this.init();\n  }\n  init() {\n    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = \"NONE\", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = !1, this.currentContext = null;\n  }\n  clean() {\n    this.prevEffects.forEach((effect) => {\n      effect.destroy && effect.destroy();\n    }), this.init(), this.removeRenderListeners();\n  }\n  getNextHook() {\n    let hook = this.currentHooks[this.nextHookIndex];\n    return this.nextHookIndex += 1, hook;\n  }\n  triggerEffects() {\n    this.prevEffects.forEach((effect) => {\n      !this.currentEffects.includes(effect) && effect.destroy && effect.destroy();\n    }), this.currentEffects.forEach((effect) => {\n      this.prevEffects.includes(effect) || (effect.destroy = effect.create());\n    }), this.prevEffects = this.currentEffects, this.currentEffects = [];\n  }\n  addRenderListeners() {\n    this.removeRenderListeners(), addons.getChannel().on(STORY_RENDERED, this.renderListener);\n  }\n  removeRenderListeners() {\n    addons.getChannel().removeListener(STORY_RENDERED, this.renderListener);\n  }\n};\nfunction hookify(fn) {\n  let hookified = (...args) => {\n    let { hooks } = typeof args[0] == \"function\" ? args[1] : args[0], prevPhase = hooks.currentPhase, prevHooks = hooks.currentHooks, prevNextHookIndex = hooks.nextHookIndex, prevDecoratorName = hooks.currentDecoratorName;\n    hooks.currentDecoratorName = fn.name, hooks.prevMountedDecorators.has(fn) ? (hooks.currentPhase = \"UPDATE\", hooks.currentHooks = hooks.hookListsMap.get(fn) || []) : (hooks.currentPhase = \"MOUNT\", hooks.currentHooks = [], hooks.hookListsMap.set(fn, hooks.currentHooks), hooks.prevMountedDecorators.add(fn)), hooks.nextHookIndex = 0;\n    let prevContext = global2.STORYBOOK_HOOKS_CONTEXT;\n    global2.STORYBOOK_HOOKS_CONTEXT = hooks;\n    let result = fn(...args);\n    if (global2.STORYBOOK_HOOKS_CONTEXT = prevContext, hooks.currentPhase === \"UPDATE\" && hooks.getNextHook() != null)\n      throw new Error(\n        \"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\"\n      );\n    return hooks.currentPhase = prevPhase, hooks.currentHooks = prevHooks, hooks.nextHookIndex = prevNextHookIndex, hooks.currentDecoratorName = prevDecoratorName, result;\n  };\n  return hookified.originalFn = fn, hookified;\n}\nvar numberOfRenders = 0, RENDER_LIMIT = 25, applyHooks = (applyDecorators) => (storyFn, decorators) => {\n  let decorated = applyDecorators(\n    hookify(storyFn),\n    decorators.map((decorator) => hookify(decorator))\n  );\n  return (context) => {\n    let { hooks } = context;\n    hooks.prevMountedDecorators ??= /* @__PURE__ */ new Set(), hooks.mountedDecorators = /* @__PURE__ */ new Set([storyFn, ...decorators]), hooks.currentContext = context, hooks.hasUpdates = !1;\n    let result = decorated(context);\n    for (numberOfRenders = 1; hooks.hasUpdates; )\n      if (hooks.hasUpdates = !1, hooks.currentEffects = [], result = decorated(context), numberOfRenders += 1, numberOfRenders > RENDER_LIMIT)\n        throw new Error(\n          \"Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.\"\n        );\n    return hooks.addRenderListeners(), result;\n  };\n}, areDepsEqual = (deps, nextDeps) => deps.length === nextDeps.length && deps.every((dep, i) => dep === nextDeps[i]), invalidHooksError = () => new Error(\"Storybook preview hooks can only be called inside decorators and story functions.\");\nfunction getHooksContextOrNull() {\n  return global2.STORYBOOK_HOOKS_CONTEXT || null;\n}\nfunction getHooksContextOrThrow() {\n  let hooks = getHooksContextOrNull();\n  if (hooks == null)\n    throw invalidHooksError();\n  return hooks;\n}\nfunction useHook(name, callback, deps) {\n  let hooks = getHooksContextOrThrow();\n  if (hooks.currentPhase === \"MOUNT\") {\n    deps != null && !Array.isArray(deps) && logger.warn(\n      `${name} received a final argument that is not an array (instead, received ${deps}). When specified, the final argument must be an array.`\n    );\n    let hook = { name, deps };\n    return hooks.currentHooks.push(hook), callback(hook), hook;\n  }\n  if (hooks.currentPhase === \"UPDATE\") {\n    let hook = hooks.getNextHook();\n    if (hook == null)\n      throw new Error(\"Rendered more hooks than during the previous render.\");\n    return hook.name !== name && logger.warn(\n      `Storybook has detected a change in the order of Hooks${hooks.currentDecoratorName ? ` called by ${hooks.currentDecoratorName}` : \"\"}. This will lead to bugs and errors if not fixed.`\n    ), deps != null && hook.deps == null && logger.warn(\n      `${name} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`\n    ), deps != null && hook.deps != null && deps.length !== hook.deps.length && logger.warn(`The final argument passed to ${name} changed size between renders. The order and size of this array must remain constant.\nPrevious: ${hook.deps}\nIncoming: ${deps}`), (deps == null || hook.deps == null || !areDepsEqual(deps, hook.deps)) && (callback(hook), hook.deps = deps), hook;\n  }\n  throw invalidHooksError();\n}\nfunction useMemoLike(name, nextCreate, deps) {\n  let { memoizedState } = useHook(\n    name,\n    (hook) => {\n      hook.memoizedState = nextCreate();\n    },\n    deps\n  );\n  return memoizedState;\n}\nfunction useMemo(nextCreate, deps) {\n  return useMemoLike(\"useMemo\", nextCreate, deps);\n}\nfunction useCallback(callback, deps) {\n  return useMemoLike(\"useCallback\", () => callback, deps);\n}\nfunction useRefLike(name, initialValue) {\n  return useMemoLike(name, () => ({ current: initialValue }), []);\n}\nfunction useRef(initialValue) {\n  return useRefLike(\"useRef\", initialValue);\n}\nfunction triggerUpdate() {\n  let hooks = getHooksContextOrNull();\n  if (hooks != null && hooks.currentPhase !== \"NONE\")\n    hooks.hasUpdates = !0;\n  else\n    try {\n      addons.getChannel().emit(FORCE_RE_RENDER);\n    } catch {\n      logger.warn(\"State updates of Storybook preview hooks work only in browser\");\n    }\n}\nfunction useStateLike(name, initialState) {\n  let stateRef = useRefLike(\n    name,\n    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript\n    typeof initialState == \"function\" ? initialState() : initialState\n  ), setState = (update) => {\n    stateRef.current = typeof update == \"function\" ? update(stateRef.current) : update, triggerUpdate();\n  };\n  return [stateRef.current, setState];\n}\nfunction useState(initialState) {\n  return useStateLike(\"useState\", initialState);\n}\nfunction useReducer(reducer, initialArg, init) {\n  let initialState = init != null ? () => init(initialArg) : initialArg, [state, setState] = useStateLike(\"useReducer\", initialState);\n  return [state, (action) => setState((prevState) => reducer(prevState, action))];\n}\nfunction useEffect(create, deps) {\n  let hooks = getHooksContextOrThrow(), effect = useMemoLike(\"useEffect\", () => ({ create }), deps);\n  hooks.currentEffects.includes(effect) || hooks.currentEffects.push(effect);\n}\nfunction useChannel(eventMap, deps = []) {\n  let channel = addons.getChannel();\n  return useEffect(() => (Object.entries(eventMap).forEach(([type, listener]) => channel.on(type, listener)), () => {\n    Object.entries(eventMap).forEach(\n      ([type, listener]) => channel.removeListener(type, listener)\n    );\n  }), [...Object.keys(eventMap), ...deps]), useCallback(channel.emit.bind(channel), [channel]);\n}\nfunction useStoryContext() {\n  let { currentContext } = getHooksContextOrThrow();\n  if (currentContext == null)\n    throw invalidHooksError();\n  return currentContext;\n}\nfunction useParameter(parameterKey, defaultValue) {\n  let { parameters } = useStoryContext();\n  if (parameterKey)\n    return parameters[parameterKey] ?? defaultValue;\n}\nfunction useArgs() {\n  let channel = addons.getChannel(), { id: storyId, args } = useStoryContext(), updateArgs = useCallback(\n    (updatedArgs) => channel.emit(UPDATE_STORY_ARGS, { storyId, updatedArgs }),\n    [channel, storyId]\n  ), resetArgs = useCallback(\n    (argNames) => channel.emit(RESET_STORY_ARGS, { storyId, argNames }),\n    [channel, storyId]\n  );\n  return [args, updateArgs, resetArgs];\n}\nfunction useGlobals() {\n  let channel = addons.getChannel(), { globals } = useStoryContext(), updateGlobals = useCallback(\n    (newGlobals) => channel.emit(UPDATE_GLOBALS, { globals: newGlobals }),\n    [channel]\n  );\n  return [globals, updateGlobals];\n}\n\n// src/preview-api/modules/addons/make-decorator.ts\nvar makeDecorator = ({\n  name,\n  parameterName,\n  wrapper,\n  skipIfNoParametersOrOptions = !1\n}) => {\n  let decorator = (options) => (storyFn, context) => {\n    let parameters = context.parameters && context.parameters[parameterName];\n    return parameters && parameters.disable || skipIfNoParametersOrOptions && !options && !parameters ? storyFn(context) : wrapper(storyFn, context, {\n      options,\n      parameters\n    });\n  };\n  return (...args) => typeof args[0] == \"function\" ? decorator()(...args) : (...innerArgs) => {\n    if (innerArgs.length > 1)\n      return args.length > 1 ? decorator(args)(...innerArgs) : decorator(...args)(...innerArgs);\n    throw new Error(\n      `Passing stories directly into ${name}() is not allowed,\n        instead use addDecorator(${name}) and pass options with the '${parameterName}' parameter`\n    );\n  };\n};\n\n// src/preview-api/modules/store/StoryStore.ts\nimport { getCoreAnnotations as getCoreAnnotations2 } from \"storybook/internal/csf\";\nimport {\n  CalledExtractOnStoreError,\n  MissingStoryFromCsfFileError\n} from \"storybook/internal/preview-errors\";\nvar import_memoizerific2 = __toESM(require_memoizerific(), 1);\n\n// src/preview-api/modules/store/args.ts\nimport { once } from \"storybook/internal/client-logger\";\nvar INCOMPATIBLE = Symbol(\"incompatible\"), map = (arg, argType) => {\n  let type = argType.type;\n  if (arg == null || !type || argType.mapping)\n    return arg;\n  switch (type.name) {\n    case \"string\":\n      return String(arg);\n    case \"enum\":\n      return arg;\n    case \"number\":\n      return Number(arg);\n    case \"boolean\":\n      return String(arg) === \"true\";\n    case \"array\":\n      return !type.value || !Array.isArray(arg) ? INCOMPATIBLE : arg.reduce((acc, item, index) => {\n        let mapped = map(item, { type: type.value });\n        return mapped !== INCOMPATIBLE && (acc[index] = mapped), acc;\n      }, new Array(arg.length));\n    case \"object\":\n      return typeof arg == \"string\" || typeof arg == \"number\" ? arg : !type.value || typeof arg != \"object\" ? INCOMPATIBLE : Object.entries(arg).reduce((acc, [key, val]) => {\n        let mapped = map(val, { type: type.value[key] });\n        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });\n      }, {});\n    case \"other\": {\n      let isPrimitiveArg = typeof arg == \"string\" || typeof arg == \"number\" || typeof arg == \"boolean\";\n      return type.value === \"ReactNode\" && isPrimitiveArg ? arg : INCOMPATIBLE;\n    }\n    default:\n      return INCOMPATIBLE;\n  }\n}, mapArgsToTypes = (args, argTypes) => Object.entries(args).reduce((acc, [key, value]) => {\n  if (!argTypes[key])\n    return acc;\n  let mapped = map(value, argTypes[key]);\n  return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });\n}, {}), combineArgs = (value, update) => Array.isArray(value) && Array.isArray(update) ? update.reduce(\n  (acc, upd, index) => (acc[index] = combineArgs(value[index], update[index]), acc),\n  [...value]\n).filter((v) => v !== void 0) : !isPlainObject(value) || !isPlainObject(update) ? update : Object.keys({ ...value, ...update }).reduce((acc, key) => {\n  if (key in update) {\n    let combined = combineArgs(value[key], update[key]);\n    combined !== void 0 && (acc[key] = combined);\n  } else\n    acc[key] = value[key];\n  return acc;\n}, {}), validateOptions = (args, argTypes) => Object.entries(argTypes).reduce((acc, [key, { options }]) => {\n  function allowArg() {\n    return key in args && (acc[key] = args[key]), acc;\n  }\n  if (!options)\n    return allowArg();\n  if (!Array.isArray(options))\n    return once.error(dedent`\n        Invalid argType: '${key}.options' should be an array.\n\n        More info: https://storybook.js.org/docs/api/arg-types?ref=error\n      `), allowArg();\n  if (options.some((opt) => opt && [\"object\", \"function\"].includes(typeof opt)))\n    return once.error(dedent`\n        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.\n\n        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values\n      `), allowArg();\n  let isArray = Array.isArray(args[key]), invalidIndex = isArray && args[key].findIndex((val) => !options.includes(val)), isValidArray = isArray && invalidIndex === -1;\n  if (args[key] === void 0 || options.includes(args[key]) || isValidArray)\n    return allowArg();\n  let field = isArray ? `${key}[${invalidIndex}]` : key, supportedOptions = options.map((opt) => typeof opt == \"string\" ? `'${opt}'` : String(opt)).join(\", \");\n  return once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`), acc;\n}, {}), DEEPLY_EQUAL = Symbol(\"Deeply equal\"), deepDiff = (value, update) => {\n  if (typeof value != typeof update)\n    return update;\n  if (isEqual(value, update))\n    return DEEPLY_EQUAL;\n  if (Array.isArray(value) && Array.isArray(update)) {\n    let res = update.reduce((acc, upd, index) => {\n      let diff = deepDiff(value[index], upd);\n      return diff !== DEEPLY_EQUAL && (acc[index] = diff), acc;\n    }, new Array(update.length));\n    return update.length >= value.length ? res : res.concat(new Array(value.length - update.length).fill(void 0));\n  }\n  return isPlainObject(value) && isPlainObject(update) ? Object.keys({ ...value, ...update }).reduce((acc, key) => {\n    let diff = deepDiff(value?.[key], update?.[key]);\n    return diff === DEEPLY_EQUAL ? acc : Object.assign(acc, { [key]: diff });\n  }, {}) : update;\n}, UNTARGETED = \"UNTARGETED\";\nfunction groupArgsByTarget({\n  args,\n  argTypes\n}) {\n  let groupedArgs = {};\n  return Object.entries(args).forEach(([name, value]) => {\n    let { target = UNTARGETED } = argTypes[name] || {};\n    groupedArgs[target] = groupedArgs[target] || {}, groupedArgs[target][name] = value;\n  }), groupedArgs;\n}\n\n// src/preview-api/modules/store/ArgsStore.ts\nfunction deleteUndefined(obj) {\n  return Object.keys(obj).forEach((key) => obj[key] === void 0 && delete obj[key]), obj;\n}\nvar ArgsStore = class {\n  constructor() {\n    this.initialArgsByStoryId = {};\n    this.argsByStoryId = {};\n  }\n  get(storyId) {\n    if (!(storyId in this.argsByStoryId))\n      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);\n    return this.argsByStoryId[storyId];\n  }\n  setInitial(story) {\n    if (!this.initialArgsByStoryId[story.id])\n      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs;\n    else if (this.initialArgsByStoryId[story.id] !== story.initialArgs) {\n      let delta = deepDiff(this.initialArgsByStoryId[story.id], this.argsByStoryId[story.id]);\n      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs, delta !== DEEPLY_EQUAL && this.updateFromDelta(story, delta);\n    }\n  }\n  updateFromDelta(story, delta) {\n    let validatedDelta = validateOptions(delta, story.argTypes);\n    this.argsByStoryId[story.id] = combineArgs(this.argsByStoryId[story.id], validatedDelta);\n  }\n  updateFromPersisted(story, persisted) {\n    let mappedPersisted = mapArgsToTypes(persisted, story.argTypes);\n    return this.updateFromDelta(story, mappedPersisted);\n  }\n  update(storyId, argsUpdate) {\n    if (!(storyId in this.argsByStoryId))\n      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);\n    this.argsByStoryId[storyId] = deleteUndefined({\n      ...this.argsByStoryId[storyId],\n      ...argsUpdate\n    });\n  }\n};\n\n// src/preview-api/modules/store/GlobalsStore.ts\nimport { logger as logger2 } from \"storybook/internal/client-logger\";\n\n// src/preview-api/modules/store/csf/getValuesFromGlobalTypes.ts\nvar getValuesFromGlobalTypes = (globalTypes = {}) => Object.entries(globalTypes).reduce((acc, [arg, { defaultValue }]) => (typeof defaultValue < \"u\" && (acc[arg] = defaultValue), acc), {});\n\n// src/preview-api/modules/store/GlobalsStore.ts\nvar GlobalsStore = class {\n  constructor({\n    globals = {},\n    globalTypes = {}\n  }) {\n    this.set({ globals, globalTypes });\n  }\n  set({ globals = {}, globalTypes = {} }) {\n    let delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);\n    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);\n    let defaultGlobals = getValuesFromGlobalTypes(globalTypes);\n    this.initialGlobals = { ...defaultGlobals, ...globals }, this.globals = this.initialGlobals, delta && delta !== DEEPLY_EQUAL && this.updateFromPersisted(delta);\n  }\n  filterAllowedGlobals(globals) {\n    return Object.entries(globals).reduce((acc, [key, value]) => (this.allowedGlobalNames.has(key) ? acc[key] = value : logger2.warn(\n      `Attempted to set a global (${key}) that is not defined in initial globals or globalTypes`\n    ), acc), {});\n  }\n  updateFromPersisted(persisted) {\n    let allowedUrlGlobals = this.filterAllowedGlobals(persisted);\n    this.globals = { ...this.globals, ...allowedUrlGlobals };\n  }\n  get() {\n    return this.globals;\n  }\n  update(newGlobals) {\n    this.globals = { ...this.globals, ...this.filterAllowedGlobals(newGlobals) };\n    for (let key in newGlobals)\n      newGlobals[key] === void 0 && (this.globals[key] = this.initialGlobals[key]);\n  }\n};\n\n// src/preview-api/modules/store/StoryIndexStore.ts\nvar import_memoizerific = __toESM(require_memoizerific(), 1);\nimport { MissingStoryAfterHmrError } from \"storybook/internal/preview-errors\";\nvar getImportPathMap = (0, import_memoizerific.default)(1)(\n  (entries) => Object.values(entries).reduce(\n    (acc, entry) => (acc[entry.importPath] = acc[entry.importPath] || entry, acc),\n    {}\n  )\n), StoryIndexStore = class {\n  constructor({ entries } = { v: 5, entries: {} }) {\n    this.entries = entries;\n  }\n  entryFromSpecifier(specifier) {\n    let entries = Object.values(this.entries);\n    if (specifier === \"*\")\n      return entries[0];\n    if (typeof specifier == \"string\")\n      return this.entries[specifier] ? this.entries[specifier] : entries.find((entry) => entry.id.startsWith(specifier));\n    let { name, title } = specifier;\n    return entries.find((entry) => entry.name === name && entry.title === title);\n  }\n  storyIdToEntry(storyId) {\n    let storyEntry = this.entries[storyId];\n    if (!storyEntry)\n      throw new MissingStoryAfterHmrError({ storyId });\n    return storyEntry;\n  }\n  importPathToEntry(importPath) {\n    return getImportPathMap(this.entries)[importPath];\n  }\n};\n\n// src/preview-api/modules/store/csf/normalizeInputTypes.ts\nvar normalizeType = (type) => typeof type == \"string\" ? { name: type } : type, normalizeControl = (control) => typeof control == \"string\" ? { type: control } : control, normalizeInputType = (inputType, key) => {\n  let { type, control, ...rest } = inputType, normalized = {\n    name: key,\n    ...rest\n  };\n  return type && (normalized.type = normalizeType(type)), control ? normalized.control = normalizeControl(control) : control === !1 && (normalized.control = { disable: !0 }), normalized;\n}, normalizeInputTypes = (inputTypes) => mapValues(inputTypes, normalizeInputType);\n\n// src/preview-api/modules/store/csf/normalizeStory.ts\nimport { deprecate, logger as logger3 } from \"storybook/internal/client-logger\";\nimport { storyNameFromExport, toId } from \"storybook/internal/csf\";\n\n// src/preview-api/modules/store/csf/normalizeArrays.ts\nvar normalizeArrays = (array) => Array.isArray(array) ? array : array ? [array] : [];\n\n// src/preview-api/modules/store/csf/normalizeStory.ts\nvar deprecatedStoryAnnotation = dedent`\nCSF .story annotations deprecated; annotate story functions directly:\n- StoryFn.story.name => StoryFn.storyName\n- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)\nSee https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.\n`;\nfunction normalizeStory(key, storyAnnotations, meta) {\n  let storyObject = storyAnnotations, userStoryFn = typeof storyAnnotations == \"function\" ? storyAnnotations : null, { story } = storyObject;\n  story && (logger3.debug(\"deprecated story\", story), deprecate(deprecatedStoryAnnotation));\n  let exportName = storyNameFromExport(key), name = typeof storyObject != \"function\" && storyObject.name || storyObject.storyName || story?.name || exportName, decorators = [\n    ...normalizeArrays(storyObject.decorators),\n    ...normalizeArrays(story?.decorators)\n  ], parameters = { ...story?.parameters, ...storyObject.parameters }, args = { ...story?.args, ...storyObject.args }, argTypes = { ...story?.argTypes, ...storyObject.argTypes }, loaders = [...normalizeArrays(storyObject.loaders), ...normalizeArrays(story?.loaders)], beforeEach = [\n    ...normalizeArrays(storyObject.beforeEach),\n    ...normalizeArrays(story?.beforeEach)\n  ], afterEach = [\n    ...normalizeArrays(storyObject.afterEach),\n    ...normalizeArrays(story?.afterEach)\n  ], { render, play, tags = [], globals = {} } = storyObject, id = parameters.__id || toId(meta.id, exportName);\n  return {\n    moduleExport: storyAnnotations,\n    id,\n    name,\n    tags,\n    decorators,\n    parameters,\n    args,\n    argTypes: normalizeInputTypes(argTypes),\n    loaders,\n    beforeEach,\n    afterEach,\n    globals,\n    ...render && { render },\n    ...userStoryFn && { userStoryFn },\n    ...play && { play }\n  };\n}\n\n// src/preview-api/modules/store/csf/processCSFFile.ts\nimport { logger as logger4 } from \"storybook/internal/client-logger\";\nimport { getStoryChildren, isExportStory, isStory, toTestId } from \"storybook/internal/csf\";\n\n// src/preview-api/modules/store/csf/normalizeComponentAnnotations.ts\nimport { sanitize } from \"storybook/internal/csf\";\nfunction normalizeComponentAnnotations(defaultExport, title = defaultExport.title, importPath) {\n  let { id, argTypes } = defaultExport;\n  return {\n    id: sanitize(id || title),\n    ...defaultExport,\n    title,\n    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },\n    parameters: {\n      fileName: importPath,\n      ...defaultExport.parameters\n    }\n  };\n}\n\n// src/preview-api/modules/store/csf/processCSFFile.ts\nvar checkGlobals = (parameters) => {\n  let { globals, globalTypes } = parameters;\n  (globals || globalTypes) && logger4.error(\n    \"Global args/argTypes can only be set globally\",\n    JSON.stringify({\n      globals,\n      globalTypes\n    })\n  );\n}, checkStorySort = (parameters) => {\n  let { options } = parameters;\n  options?.storySort && logger4.error(\"The storySort option parameter can only be set globally\");\n}, checkDisallowedParameters = (parameters) => {\n  parameters && (checkGlobals(parameters), checkStorySort(parameters));\n};\nfunction processCSFFile(moduleExports, importPath, title) {\n  let { default: defaultExport, __namedExportsOrder, ...namedExports } = moduleExports, factoryStory = Object.values(namedExports).find((it) => isStory(it));\n  if (factoryStory) {\n    let meta2 = normalizeComponentAnnotations(factoryStory.meta.input, title, importPath);\n    checkDisallowedParameters(meta2.parameters);\n    let csfFile2 = { meta: meta2, stories: {}, moduleExports };\n    return Object.keys(namedExports).forEach((key) => {\n      if (isExportStory(key, meta2) && isStory(namedExports[key])) {\n        let story = namedExports[key], storyMeta = normalizeStory(key, story.input, meta2);\n        checkDisallowedParameters(storyMeta.parameters), csfFile2.stories[storyMeta.id] = storyMeta, getStoryChildren(story).forEach((child) => {\n          let name = child.input.name, childId = toTestId(storyMeta.id, name);\n          child.input.parameters ??= {}, child.input.parameters.__id = childId, csfFile2.stories[childId] = normalizeStory(name, child.input, meta2);\n        });\n      }\n    }), csfFile2.projectAnnotations = factoryStory.meta.preview.composed, csfFile2;\n  }\n  let meta = normalizeComponentAnnotations(\n    defaultExport,\n    title,\n    importPath\n  );\n  checkDisallowedParameters(meta.parameters);\n  let csfFile = { meta, stories: {}, moduleExports };\n  return Object.keys(namedExports).forEach((key) => {\n    if (isExportStory(key, meta)) {\n      let storyMeta = normalizeStory(key, namedExports[key], meta);\n      checkDisallowedParameters(storyMeta.parameters), csfFile.stories[storyMeta.id] = storyMeta;\n    }\n  }), csfFile;\n}\n\n// src/preview-api/modules/store/csf/prepareStory.ts\nimport { combineTags, includeConditionalArg } from \"storybook/internal/csf\";\nimport { NoRenderFunctionError } from \"storybook/internal/preview-errors\";\nimport { global as global3 } from \"@storybook/global\";\nimport { global as globalThis2 } from \"@storybook/global\";\n\n// src/preview-api/modules/preview-web/render/mount-utils.ts\nfunction mountDestructured(playFunction) {\n  return playFunction != null && getUsedProps(playFunction).includes(\"mount\");\n}\nfunction getUsedProps(fn) {\n  let [, args, body] = fn.toString().match(/[^(]*\\(([^)]+)\\)(?:.*{([^]+)})?/) || [];\n  if (!args)\n    return [];\n  let [firstArg] = splitByComma(args);\n  if (!firstArg)\n    return [];\n  let [, destructuredProps] = firstArg.match(/^{([^]+)}$/) || [];\n  if (destructuredProps)\n    return splitByComma(stripComments(destructuredProps)).map(\n      (prop) => prop.replace(/:.*|=.*/g, \"\").trim()\n    );\n  if (!firstArg.match(/^[a-z_$][0-9a-z_$]*$/i))\n    return [];\n  let escapedArg = firstArg.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), [, destructuredArg] = body?.trim()?.match(new RegExp(`^(?:const|let|var)\\\\s*{([^}]+)}\\\\s*=\\\\s*${escapedArg};`)) || [];\n  return destructuredArg ? splitByComma(stripComments(destructuredArg)).map(\n    (prop) => prop.replace(/:.*|=.*/g, \"\").trim()\n  ) : [];\n}\nfunction stripComments(s) {\n  return s = s.replace(/\\/\\/.*$/gm, \"\"), s = s.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\"), s;\n}\nfunction splitByComma(s) {\n  let result = [], stack = [], start = 0;\n  for (let i = 0; i < s.length; i++)\n    if (s[i] === \"{\" || s[i] === \"[\")\n      stack.push(s[i] === \"{\" ? \"}\" : \"]\");\n    else if (s[i] === stack[stack.length - 1])\n      stack.pop();\n    else if (!stack.length && s[i] === \",\") {\n      let token = s.substring(start, i).trim();\n      token && result.push(token), start = i + 1;\n    }\n  let lastToken = s.substring(start).trim();\n  return lastToken && result.push(lastToken), result;\n}\n\n// src/preview-api/modules/store/decorators.ts\nfunction decorateStory(storyFn, decorator, bindWithContext) {\n  let boundStoryFunction = bindWithContext(storyFn);\n  return (context) => decorator(boundStoryFunction, context);\n}\nfunction sanitizeStoryContextUpdate({\n  componentId,\n  title,\n  kind,\n  id,\n  name,\n  story,\n  parameters,\n  initialArgs,\n  argTypes,\n  ...update\n} = {}) {\n  return update;\n}\nfunction defaultDecorateStory(storyFn, decorators) {\n  let contextStore = {}, bindWithContext = (decoratedStoryFn) => (update) => {\n    if (!contextStore.value)\n      throw new Error(\"Decorated function called without init\");\n    return contextStore.value = {\n      ...contextStore.value,\n      ...sanitizeStoryContextUpdate(update)\n    }, decoratedStoryFn(contextStore.value);\n  }, decoratedWithContextStore = decorators.reduce(\n    (story, decorator) => decorateStory(story, decorator, bindWithContext),\n    storyFn\n  );\n  return (context) => (contextStore.value = context, decoratedWithContextStore(context));\n}\n\n// src/preview-api/modules/store/csf/prepareStory.ts\nfunction prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {\n  let { moduleExport, id, name } = storyAnnotations || {}, partialAnnotations = preparePartialAnnotations(\n    storyAnnotations,\n    componentAnnotations,\n    projectAnnotations\n  ), applyLoaders = async (context) => {\n    let loaded = {};\n    for (let loaders of [\n      normalizeArrays(projectAnnotations.loaders),\n      normalizeArrays(componentAnnotations.loaders),\n      normalizeArrays(storyAnnotations.loaders)\n    ]) {\n      if (context.abortSignal.aborted)\n        return loaded;\n      let loadResults = await Promise.all(loaders.map((loader) => loader(context)));\n      Object.assign(loaded, ...loadResults);\n    }\n    return loaded;\n  }, applyBeforeEach = async (context) => {\n    let cleanupCallbacks = new Array();\n    for (let beforeEach of [\n      ...normalizeArrays(projectAnnotations.beforeEach),\n      ...normalizeArrays(componentAnnotations.beforeEach),\n      ...normalizeArrays(storyAnnotations.beforeEach)\n    ]) {\n      if (context.abortSignal.aborted)\n        return cleanupCallbacks;\n      let cleanup = await beforeEach(context);\n      cleanup && cleanupCallbacks.push(cleanup);\n    }\n    return cleanupCallbacks;\n  }, applyAfterEach = async (context) => {\n    let reversedFinalizers = [\n      ...normalizeArrays(projectAnnotations.afterEach),\n      ...normalizeArrays(componentAnnotations.afterEach),\n      ...normalizeArrays(storyAnnotations.afterEach)\n    ].reverse();\n    for (let finalizer of reversedFinalizers) {\n      if (context.abortSignal.aborted)\n        return;\n      await finalizer(context);\n    }\n  }, undecoratedStoryFn = (context) => context.originalStoryFn(context.args, context), { applyDecorators = defaultDecorateStory, runStep } = projectAnnotations, decorators = [\n    ...normalizeArrays(storyAnnotations?.decorators),\n    ...normalizeArrays(componentAnnotations?.decorators),\n    ...normalizeArrays(projectAnnotations?.decorators)\n  ], render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render, decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators), unboundStoryFn = (context) => decoratedStoryFn(context), playFunction = storyAnnotations?.play ?? componentAnnotations?.play, usesMount = mountDestructured(playFunction);\n  if (!render && !usesMount)\n    throw new NoRenderFunctionError({ id });\n  let defaultMount = (context) => async () => (await context.renderToCanvas(), context.canvas), mount = storyAnnotations.mount ?? componentAnnotations.mount ?? projectAnnotations.mount ?? defaultMount, testingLibraryRender = projectAnnotations.testingLibraryRender;\n  return {\n    storyGlobals: {},\n    ...partialAnnotations,\n    moduleExport,\n    id,\n    name,\n    story: name,\n    originalStoryFn: render,\n    undecoratedStoryFn,\n    unboundStoryFn,\n    applyLoaders,\n    applyBeforeEach,\n    applyAfterEach,\n    playFunction,\n    runStep,\n    mount,\n    testingLibraryRender,\n    renderToCanvas: projectAnnotations.renderToCanvas,\n    usesMount\n  };\n}\nfunction prepareMeta(componentAnnotations, projectAnnotations, moduleExport) {\n  return {\n    ...preparePartialAnnotations(void 0, componentAnnotations, projectAnnotations),\n    moduleExport\n  };\n}\nfunction preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations) {\n  let defaultTags = [Tag.DEV, Tag.TEST], extraTags = globalThis2.DOCS_OPTIONS?.autodocs === !0 ? [Tag.AUTODOCS] : [], overrideTags = storyAnnotations?.tags?.includes(Tag.TEST_FN) ? [`!${Tag.AUTODOCS}`] : [], tags = combineTags(\n    ...defaultTags,\n    ...extraTags,\n    ...projectAnnotations.tags ?? [],\n    ...componentAnnotations.tags ?? [],\n    ...overrideTags,\n    ...storyAnnotations?.tags ?? []\n  ), parameters = combineParameters(\n    projectAnnotations.parameters,\n    componentAnnotations.parameters,\n    storyAnnotations?.parameters\n  ), { argTypesEnhancers = [], argsEnhancers = [] } = projectAnnotations, passedArgTypes = combineParameters(\n    projectAnnotations.argTypes,\n    componentAnnotations.argTypes,\n    storyAnnotations?.argTypes\n  );\n  if (storyAnnotations) {\n    let render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render;\n    parameters.__isArgsStory = render && render.length > 0;\n  }\n  let passedArgs = {\n    ...projectAnnotations.args,\n    ...componentAnnotations.args,\n    ...storyAnnotations?.args\n  }, storyGlobals = {\n    ...componentAnnotations.globals,\n    ...storyAnnotations?.globals\n  }, contextForEnhancers = {\n    componentId: componentAnnotations.id,\n    title: componentAnnotations.title,\n    kind: componentAnnotations.title,\n    // Back compat\n    id: storyAnnotations?.id || componentAnnotations.id,\n    // if there's no story name, we create a fake one since enhancers expect a name\n    name: storyAnnotations?.name || \"__meta\",\n    story: storyAnnotations?.name || \"__meta\",\n    // Back compat\n    component: componentAnnotations.component,\n    subcomponents: componentAnnotations.subcomponents,\n    tags,\n    parameters,\n    initialArgs: passedArgs,\n    argTypes: passedArgTypes,\n    storyGlobals\n  };\n  contextForEnhancers.argTypes = argTypesEnhancers.reduce(\n    (accumulatedArgTypes, enhancer) => enhancer({ ...contextForEnhancers, argTypes: accumulatedArgTypes }),\n    contextForEnhancers.argTypes\n  );\n  let initialArgsBeforeEnhancers = { ...passedArgs };\n  contextForEnhancers.initialArgs = [...argsEnhancers].reduce(\n    (accumulatedArgs, enhancer) => ({\n      ...accumulatedArgs,\n      ...enhancer({\n        ...contextForEnhancers,\n        initialArgs: accumulatedArgs\n      })\n    }),\n    initialArgsBeforeEnhancers\n  );\n  let { name, story, ...withoutStoryIdentifiers } = contextForEnhancers;\n  return withoutStoryIdentifiers;\n}\nfunction prepareContext(context) {\n  let { args: unmappedArgs } = context, targetedContext = {\n    ...context,\n    allArgs: void 0,\n    argsByTarget: void 0\n  };\n  if (global3.FEATURES?.argTypeTargetsV7) {\n    let argsByTarget = groupArgsByTarget(context);\n    targetedContext = {\n      ...context,\n      allArgs: context.args,\n      argsByTarget,\n      args: argsByTarget[UNTARGETED] || {}\n    };\n  }\n  let mappedArgs = Object.entries(targetedContext.args).reduce((acc, [key, val]) => {\n    if (!targetedContext.argTypes[key]?.mapping)\n      return acc[key] = val, acc;\n    let mappingFn = (originalValue) => {\n      let mapping = targetedContext.argTypes[key].mapping;\n      return mapping && originalValue in mapping ? mapping[originalValue] : originalValue;\n    };\n    return acc[key] = Array.isArray(val) ? val.map(mappingFn) : mappingFn(val), acc;\n  }, {}), includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {\n    let argType = targetedContext.argTypes[key] || {};\n    return includeConditionalArg(argType, mappedArgs, targetedContext.globals) && (acc[key] = val), acc;\n  }, {});\n  return { ...targetedContext, unmappedArgs, args: includedArgs };\n}\n\n// src/preview-api/modules/store/inferArgTypes.ts\nimport { logger as logger5 } from \"storybook/internal/client-logger\";\nvar inferType = (value, name, visited) => {\n  let type = typeof value;\n  switch (type) {\n    case \"boolean\":\n    case \"string\":\n    case \"number\":\n    case \"function\":\n    case \"symbol\":\n      return { name: type };\n    default:\n      break;\n  }\n  return value ? visited.has(value) ? (logger5.warn(dedent`\n        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.\n\n        Consider using the mapping feature or fully custom args:\n        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values\n        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args\n      `), { name: \"other\", value: \"cyclic object\" }) : (visited.add(value), Array.isArray(value) ? { name: \"array\", value: value.length > 0 ? inferType(value[0], name, new Set(visited)) : { name: \"other\", value: \"unknown\" } } : { name: \"object\", value: mapValues(value, (field) => inferType(field, name, new Set(visited))) }) : { name: \"object\", value: {} };\n}, inferArgTypes = (context) => {\n  let { id, argTypes: userArgTypes = {}, initialArgs = {} } = context, argTypes = mapValues(initialArgs, (arg, key) => ({\n    name: key,\n    type: inferType(arg, `${id}.${key}`, /* @__PURE__ */ new Set())\n  })), userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({\n    name: key\n  }));\n  return combineParameters(argTypes, userArgTypesNames, userArgTypes);\n};\ninferArgTypes.secondPass = !0;\n\n// src/preview-api/modules/store/inferControls.ts\nimport { logger as logger6 } from \"storybook/internal/client-logger\";\n\n// src/preview-api/modules/store/filterArgTypes.ts\nvar matches = (name, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor), filterArgTypes = (argTypes, include, exclude) => !include && !exclude ? argTypes : argTypes && pickBy(argTypes, (argType, key) => {\n  let name = argType.name || key.toString();\n  return !!(!include || matches(name, include)) && (!exclude || !matches(name, exclude));\n});\n\n// src/preview-api/modules/store/inferControls.ts\nvar inferControl = (argType, name, matchers) => {\n  let { type, options } = argType;\n  if (type) {\n    if (matchers.color && matchers.color.test(name)) {\n      let controlType = type.name;\n      if (controlType === \"string\")\n        return { control: { type: \"color\" } };\n      controlType !== \"enum\" && logger6.warn(\n        `Addon controls: Control of type color only supports string, received \"${controlType}\" instead`\n      );\n    }\n    if (matchers.date && matchers.date.test(name))\n      return { control: { type: \"date\" } };\n    switch (type.name) {\n      case \"array\":\n        return { control: { type: \"object\" } };\n      case \"boolean\":\n        return { control: { type: \"boolean\" } };\n      case \"string\":\n        return { control: { type: \"text\" } };\n      case \"number\":\n        return { control: { type: \"number\" } };\n      case \"enum\": {\n        let { value } = type;\n        return { control: { type: value?.length <= 5 ? \"radio\" : \"select\" }, options: value };\n      }\n      case \"function\":\n      case \"symbol\":\n        return null;\n      default:\n        return { control: { type: options ? \"select\" : \"object\" } };\n    }\n  }\n}, inferControls = (context) => {\n  let {\n    argTypes,\n    parameters: { __isArgsStory, controls: { include = null, exclude = null, matchers = {} } = {} }\n  } = context;\n  if (!__isArgsStory)\n    return argTypes;\n  let filteredArgTypes = filterArgTypes(argTypes, include, exclude), withControls = mapValues(filteredArgTypes, (argType, name) => argType?.type && inferControl(argType, name.toString(), matchers));\n  return combineParameters(withControls, filteredArgTypes);\n};\ninferControls.secondPass = !0;\n\n// src/preview-api/modules/store/csf/normalizeProjectAnnotations.ts\nfunction normalizeProjectAnnotations({\n  argTypes,\n  argTypesEnhancers,\n  decorators,\n  loaders,\n  beforeEach,\n  afterEach,\n  initialGlobals,\n  ...annotations\n}) {\n  return {\n    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },\n    decorators: normalizeArrays(decorators),\n    loaders: normalizeArrays(loaders),\n    beforeEach: normalizeArrays(beforeEach),\n    afterEach: normalizeArrays(afterEach),\n    argTypesEnhancers: [\n      ...argTypesEnhancers || [],\n      inferArgTypes,\n      // There's an architectural decision to be made regarding embedded addons in core:\n      //\n      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code\n      // (like inferControls) to live alongside the addon code itself. This maintains the\n      // concept of core addons while improving code organization.\n      //\n      // Option 2: Fully integrate these addons into core, potentially moving UI components\n      // into the manager and treating them as core features rather than addons. This is a\n      // bigger architectural change requiring careful consideration.\n      //\n      // For now, we're keeping inferControls here as we need time to properly evaluate\n      // these options and their implications. Some features (like Angular's cleanArgsDecorator)\n      // currently rely on this behavior.\n      //\n      // TODO: Make an architectural decision on the handling of core addons\n      inferControls\n    ],\n    initialGlobals,\n    ...annotations\n  };\n}\n\n// src/preview-api/modules/store/csf/composeConfigs.ts\nimport { global as global4 } from \"@storybook/global\";\n\n// src/preview-api/modules/store/csf/beforeAll.ts\nvar composeBeforeAllHooks = (hooks) => async () => {\n  let cleanups2 = [];\n  for (let hook of hooks) {\n    let cleanup = await hook();\n    cleanup && cleanups2.unshift(cleanup);\n  }\n  return async () => {\n    for (let cleanup of cleanups2)\n      await cleanup();\n  };\n};\n\n// src/preview-api/modules/store/csf/stepRunners.ts\nfunction composeStepRunners(stepRunners) {\n  return async (label, play, playContext) => {\n    await stepRunners.reduceRight(\n      (innerPlay, stepRunner) => async () => stepRunner(label, innerPlay, playContext),\n      async () => play(playContext)\n    )();\n  };\n}\n\n// src/preview-api/modules/store/csf/composeConfigs.ts\nfunction getField(moduleExportList, field) {\n  return moduleExportList.map((xs) => xs.default?.[field] ?? xs[field]).filter(Boolean);\n}\nfunction getArrayField(moduleExportList, field, options = {}) {\n  return getField(moduleExportList, field).reduce((prev, cur) => {\n    let normalized = normalizeArrays(cur);\n    return options.reverseFileOrder ? [...normalized, ...prev] : [...prev, ...normalized];\n  }, []);\n}\nfunction getObjectField(moduleExportList, field) {\n  return Object.assign({}, ...getField(moduleExportList, field));\n}\nfunction getSingletonField(moduleExportList, field) {\n  return getField(moduleExportList, field).pop();\n}\nfunction composeConfigs(moduleExportList) {\n  let allArgTypeEnhancers = getArrayField(moduleExportList, \"argTypesEnhancers\"), stepRunners = getField(moduleExportList, \"runStep\"), beforeAllHooks = getArrayField(moduleExportList, \"beforeAll\");\n  return {\n    parameters: combineParameters(...getField(moduleExportList, \"parameters\")),\n    decorators: getArrayField(moduleExportList, \"decorators\", {\n      reverseFileOrder: !(global4.FEATURES?.legacyDecoratorFileOrder ?? !1)\n    }),\n    args: getObjectField(moduleExportList, \"args\"),\n    argsEnhancers: getArrayField(moduleExportList, \"argsEnhancers\"),\n    argTypes: getObjectField(moduleExportList, \"argTypes\"),\n    argTypesEnhancers: [\n      ...allArgTypeEnhancers.filter((e) => !e.secondPass),\n      ...allArgTypeEnhancers.filter((e) => e.secondPass)\n    ],\n    initialGlobals: getObjectField(moduleExportList, \"initialGlobals\"),\n    globalTypes: getObjectField(moduleExportList, \"globalTypes\"),\n    loaders: getArrayField(moduleExportList, \"loaders\"),\n    beforeAll: composeBeforeAllHooks(beforeAllHooks),\n    beforeEach: getArrayField(moduleExportList, \"beforeEach\"),\n    afterEach: getArrayField(moduleExportList, \"afterEach\"),\n    render: getSingletonField(moduleExportList, \"render\"),\n    renderToCanvas: getSingletonField(moduleExportList, \"renderToCanvas\"),\n    applyDecorators: getSingletonField(moduleExportList, \"applyDecorators\"),\n    runStep: composeStepRunners(stepRunners),\n    tags: getArrayField(moduleExportList, \"tags\"),\n    mount: getSingletonField(moduleExportList, \"mount\"),\n    testingLibraryRender: getSingletonField(moduleExportList, \"testingLibraryRender\")\n  };\n}\n\n// src/preview-api/modules/store/csf/portable-stories.ts\nimport { isExportStory as isExportStory2 } from \"storybook/internal/csf\";\nimport { getCoreAnnotations } from \"storybook/internal/csf\";\nimport { MountMustBeDestructuredError } from \"storybook/internal/preview-errors\";\n\n// src/preview-api/modules/store/reporter-api.ts\nvar ReporterAPI = class {\n  constructor() {\n    this.reports = [];\n  }\n  async addReport(report) {\n    this.reports.push(report);\n  }\n};\n\n// src/preview-api/modules/store/csf/csf-factory-utils.ts\nimport { isMeta, isStory as isStory2 } from \"storybook/internal/csf\";\nfunction getCsfFactoryAnnotations(story, meta, projectAnnotations) {\n  return isStory2(story) ? {\n    story: story.input,\n    meta: story.meta.input,\n    preview: story.meta.preview.composed\n  } : { story, meta: isMeta(meta) ? meta.input : meta, preview: projectAnnotations };\n}\n\n// src/preview-api/modules/store/csf/portable-stories.ts\nfunction setDefaultProjectAnnotations(_defaultProjectAnnotations) {\n  globalThis.defaultProjectAnnotations = _defaultProjectAnnotations;\n}\nvar DEFAULT_STORY_TITLE = \"ComposedStory\", DEFAULT_STORY_NAME = \"Unnamed Story\";\nfunction extractAnnotation(annotation) {\n  return annotation ? composeConfigs([annotation]) : {};\n}\nfunction setProjectAnnotations(projectAnnotations) {\n  let annotations = Array.isArray(projectAnnotations) ? projectAnnotations : [projectAnnotations];\n  return globalThis.globalProjectAnnotations = composeConfigs([\n    ...getCoreAnnotations(),\n    globalThis.defaultProjectAnnotations ?? {},\n    composeConfigs(annotations.map(extractAnnotation))\n  ]), globalThis.globalProjectAnnotations ?? {};\n}\nvar cleanups = [];\nfunction composeStory(storyAnnotations, componentAnnotations, projectAnnotations, defaultConfig, exportsName) {\n  if (storyAnnotations === void 0)\n    throw new Error(\"Expected a story but received undefined.\");\n  componentAnnotations.title = componentAnnotations.title ?? DEFAULT_STORY_TITLE;\n  let normalizedComponentAnnotations = normalizeComponentAnnotations(componentAnnotations), storyName = exportsName || storyAnnotations.storyName || storyAnnotations.story?.name || storyAnnotations.name || DEFAULT_STORY_NAME, normalizedStory = normalizeStory(\n    storyName,\n    storyAnnotations,\n    normalizedComponentAnnotations\n  ), normalizedProjectAnnotations = normalizeProjectAnnotations(\n    composeConfigs([\n      defaultConfig ?? globalThis.globalProjectAnnotations ?? {},\n      projectAnnotations ?? {}\n    ])\n  ), story = prepareStory(\n    normalizedStory,\n    normalizedComponentAnnotations,\n    normalizedProjectAnnotations\n  ), globals = {\n    ...getValuesFromGlobalTypes(normalizedProjectAnnotations.globalTypes),\n    ...normalizedProjectAnnotations.initialGlobals,\n    ...story.storyGlobals\n  }, reporting = new ReporterAPI(), initializeContext = () => {\n    let context = prepareContext({\n      hooks: new HooksContext(),\n      globals,\n      args: { ...story.initialArgs },\n      viewMode: \"story\",\n      reporting,\n      loaded: {},\n      abortSignal: new AbortController().signal,\n      step: (label, play2) => story.runStep(label, play2, context),\n      canvasElement: null,\n      canvas: {},\n      userEvent: {},\n      globalTypes: normalizedProjectAnnotations.globalTypes,\n      ...story,\n      context: null,\n      mount: null\n    });\n    return context.parameters.__isPortableStory = !0, context.context = context, story.renderToCanvas && (context.renderToCanvas = async () => {\n      let unmount = await story.renderToCanvas?.(\n        {\n          componentId: story.componentId,\n          title: story.title,\n          id: story.id,\n          name: story.name,\n          tags: story.tags,\n          showMain: () => {\n          },\n          showError: (error) => {\n            throw new Error(`${error.title}\n${error.description}`);\n          },\n          showException: (error) => {\n            throw error;\n          },\n          forceRemount: !0,\n          storyContext: context,\n          storyFn: () => story.unboundStoryFn(context),\n          unboundStoryFn: story.unboundStoryFn\n        },\n        context.canvasElement\n      );\n      unmount && cleanups.push(unmount);\n    }), context.mount = story.mount(context), context;\n  }, loadedContext, play = async (extraContext) => {\n    let context = initializeContext();\n    return context.canvasElement ??= globalThis?.document?.body, loadedContext && (context.loaded = loadedContext.loaded), Object.assign(context, extraContext), story.playFunction(context);\n  }, run = (extraContext) => {\n    let context = initializeContext();\n    return Object.assign(context, extraContext), runStory(story, context);\n  }, playFunction = story.playFunction ? play : void 0;\n  return Object.assign(\n    function(extraArgs) {\n      let context = initializeContext();\n      return loadedContext && (context.loaded = loadedContext.loaded), context.args = {\n        ...context.initialArgs,\n        ...extraArgs\n      }, story.unboundStoryFn(context);\n    },\n    {\n      id: story.id,\n      storyName,\n      load: async () => {\n        for (let callback of [...cleanups].reverse())\n          await callback();\n        cleanups.length = 0;\n        let context = initializeContext();\n        context.loaded = await story.applyLoaders(context), cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean)), loadedContext = context;\n      },\n      globals,\n      args: story.initialArgs,\n      parameters: story.parameters,\n      argTypes: story.argTypes,\n      play: playFunction,\n      run,\n      reporting,\n      tags: story.tags\n    }\n  );\n}\nvar defaultComposeStory = (story, component, project, exportsName) => composeStory(story, component, project, {}, exportsName);\nfunction composeStories(storiesImport, globalConfig, composeStoryFn = defaultComposeStory) {\n  let { default: metaExport, __esModule, __namedExportsOrder, ...stories } = storiesImport, meta = metaExport;\n  return Object.entries(stories).reduce(\n    (storiesMap, [exportsName, story]) => {\n      let { story: storyAnnotations, meta: componentAnnotations } = getCsfFactoryAnnotations(story);\n      return !meta && componentAnnotations && (meta = componentAnnotations), isExportStory2(exportsName, meta) ? Object.assign(storiesMap, {\n        [exportsName]: composeStoryFn(storyAnnotations, meta, globalConfig, exportsName)\n      }) : storiesMap;\n    },\n    {}\n  );\n}\nfunction createPlaywrightTest(baseTest) {\n  return baseTest.extend({\n    mount: async ({ mount, page }, use) => {\n      await use(async (storyRef, ...restArgs) => {\n        if (!(\"__pw_type\" in storyRef) || \"__pw_type\" in storyRef && storyRef.__pw_type !== \"jsx\")\n          throw new Error(dedent`\n              Portable stories in Playwright CT only work when referencing JSX elements.\n              Please use JSX format for your components such as:\n\n              instead of:\n              await mount(MyComponent, { props: { foo: 'bar' } })\n\n              do:\n              await mount(<MyComponent foo=\"bar\"/>)\n\n              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error\n            `);\n        let { props, ...storyRefWithoutProps } = storyRef;\n        await page.evaluate(async (wrappedStoryRef) => {\n          let unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef);\n          return (\"__pw_type\" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef)?.load?.();\n        }, storyRefWithoutProps);\n        let mountResult = await mount(storyRef, ...restArgs);\n        return await page.evaluate(async (wrappedStoryRef) => {\n          let unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef), story = \"__pw_type\" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef, canvasElement = document.querySelector(\"#root\");\n          return story?.play?.({ canvasElement });\n        }, storyRefWithoutProps), mountResult;\n      });\n    }\n  });\n}\nasync function runStory(story, context) {\n  for (let callback of [...cleanups].reverse())\n    await callback();\n  if (cleanups.length = 0, !context.canvasElement) {\n    let container = document.createElement(\"div\");\n    globalThis?.document?.body?.appendChild(container), context.canvasElement = container, cleanups.push(() => {\n      globalThis?.document?.body?.contains(container) && globalThis?.document?.body?.removeChild(container);\n    });\n  }\n  if (context.loaded = await story.applyLoaders(context), context.abortSignal.aborted)\n    return;\n  cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean));\n  let playFunction = story.playFunction, isMountDestructured = story.usesMount;\n  if (isMountDestructured || await context.mount(), context.abortSignal.aborted)\n    return;\n  playFunction && (isMountDestructured || (context.mount = async () => {\n    throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });\n  }), await playFunction(context));\n  let cleanUp;\n  isTestEnvironment() ? cleanUp = pauseAnimations() : await waitForAnimations(context.abortSignal), await story.applyAfterEach(context), await cleanUp?.();\n}\n\n// src/preview-api/modules/store/StoryStore.ts\nvar CSF_CACHE_SIZE = 1e3, STORY_CACHE_SIZE = 1e4, StoryStore = class {\n  constructor(storyIndex, importFn, projectAnnotations) {\n    this.importFn = importFn;\n    this.storyIndex = new StoryIndexStore(storyIndex), this.projectAnnotations = normalizeProjectAnnotations(\n      composeConfigs([...getCoreAnnotations2(), projectAnnotations])\n    );\n    let { initialGlobals, globalTypes } = this.projectAnnotations;\n    this.args = new ArgsStore(), this.userGlobals = new GlobalsStore({ globals: initialGlobals, globalTypes }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(processCSFFile), this.prepareMetaWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(prepareMeta), this.prepareStoryWithCache = (0, import_memoizerific2.default)(STORY_CACHE_SIZE)(prepareStory);\n  }\n  setProjectAnnotations(projectAnnotations) {\n    this.projectAnnotations = normalizeProjectAnnotations(projectAnnotations);\n    let { initialGlobals, globalTypes } = projectAnnotations;\n    this.userGlobals.set({ globals: initialGlobals, globalTypes });\n  }\n  // This means that one of the CSF files has changed.\n  // If the `importFn` has changed, we will invalidate both caches.\n  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending\n  // on whether we've loaded the relevant files yet.\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    importFn && (this.importFn = importFn), storyIndex && (this.storyIndex.entries = storyIndex.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();\n  }\n  // Get an entry from the index, waiting on initialization if necessary\n  async storyIdToEntry(storyId) {\n    return this.storyIndex.storyIdToEntry(storyId);\n  }\n  // To load a single CSF file to service a story we need to look up the importPath in the index\n  async loadCSFFileByStoryId(storyId) {\n    let { importPath, title } = this.storyIndex.storyIdToEntry(storyId), moduleExports = await this.importFn(importPath);\n    return this.processCSFFileWithCache(moduleExports, importPath, title);\n  }\n  async loadAllCSFFiles() {\n    let importPaths = {};\n    return Object.entries(this.storyIndex.entries).forEach(([storyId, { importPath }]) => {\n      importPaths[importPath] = storyId;\n    }), (await Promise.all(\n      Object.entries(importPaths).map(async ([importPath, storyId]) => ({\n        importPath,\n        csfFile: await this.loadCSFFileByStoryId(storyId)\n      }))\n    )).reduce(\n      (acc, { importPath, csfFile }) => (acc[importPath] = csfFile, acc),\n      {}\n    );\n  }\n  async cacheAllCSFFiles() {\n    this.cachedCSFFiles = await this.loadAllCSFFiles();\n  }\n  preparedMetaFromCSFFile({ csfFile }) {\n    let componentAnnotations = csfFile.meta;\n    return this.prepareMetaWithCache(\n      componentAnnotations,\n      this.projectAnnotations,\n      csfFile.moduleExports.default\n    );\n  }\n  // Load the CSF file for a story and prepare the story from it and the project annotations.\n  async loadStory({ storyId }) {\n    let csfFile = await this.loadCSFFileByStoryId(storyId);\n    return this.storyFromCSFFile({ storyId, csfFile });\n  }\n  // This function is synchronous for convenience -- often times if you have a CSF file already\n  // it is easier not to have to await `loadStory`.\n  storyFromCSFFile({\n    storyId,\n    csfFile\n  }) {\n    let storyAnnotations = csfFile.stories[storyId];\n    if (!storyAnnotations)\n      throw new MissingStoryFromCsfFileError({ storyId });\n    let componentAnnotations = csfFile.meta, story = this.prepareStoryWithCache(\n      storyAnnotations,\n      componentAnnotations,\n      csfFile.projectAnnotations ?? this.projectAnnotations\n    );\n    return this.args.setInitial(story), this.hooks[story.id] = this.hooks[story.id] || new HooksContext(), story;\n  }\n  // If we have a CSF file we can get all the stories from it synchronously\n  componentStoriesFromCSFFile({\n    csfFile\n  }) {\n    return Object.keys(this.storyIndex.entries).filter((storyId) => !!csfFile.stories[storyId]).map((storyId) => this.storyFromCSFFile({ storyId, csfFile }));\n  }\n  async loadEntry(id) {\n    let entry = await this.storyIdToEntry(id), storyImports = entry.type === \"docs\" ? entry.storiesImports : [], [entryExports, ...csfFiles] = await Promise.all([\n      this.importFn(entry.importPath),\n      ...storyImports.map((storyImportPath) => {\n        let firstStoryEntry = this.storyIndex.importPathToEntry(storyImportPath);\n        return this.loadCSFFileByStoryId(firstStoryEntry.id);\n      })\n    ]);\n    return { entryExports, csfFiles };\n  }\n  // A prepared story does not include args, globals or hooks. These are stored in the story store\n  // and updated separately to the (immutable) story.\n  getStoryContext(story, { forceInitialArgs = !1 } = {}) {\n    let userGlobals = this.userGlobals.get(), { initialGlobals } = this.userGlobals, reporting = new ReporterAPI();\n    return prepareContext({\n      ...story,\n      args: forceInitialArgs ? story.initialArgs : this.args.get(story.id),\n      initialGlobals,\n      globalTypes: this.projectAnnotations.globalTypes,\n      userGlobals,\n      reporting,\n      globals: {\n        ...userGlobals,\n        ...story.storyGlobals\n      },\n      hooks: this.hooks[story.id]\n    });\n  }\n  addCleanupCallbacks(story, ...callbacks) {\n    this.cleanupCallbacks[story.id] = (this.cleanupCallbacks[story.id] || []).concat(callbacks);\n  }\n  async cleanupStory(story) {\n    this.hooks[story.id].clean();\n    let callbacks = this.cleanupCallbacks[story.id];\n    if (callbacks)\n      for (let callback of [...callbacks].reverse())\n        await callback();\n    delete this.cleanupCallbacks[story.id];\n  }\n  extract(options = { includeDocsOnly: !1 }) {\n    let { cachedCSFFiles } = this;\n    if (console.log(\"extract: extracting stories\", cachedCSFFiles), !cachedCSFFiles)\n      throw new CalledExtractOnStoreError();\n    let stories = Object.entries(this.storyIndex.entries).reduce(\n      (acc, [storyId, entry]) => {\n        if (entry.type === \"docs\")\n          return acc;\n        let csfFile = cachedCSFFiles[entry.importPath], story = this.storyFromCSFFile({ storyId, csfFile });\n        return !options.includeDocsOnly && story.parameters.docsOnly || (acc[storyId] = Object.entries(story).reduce(\n          (storyAcc, [key, value]) => key === \"story\" && entry.subtype === \"test\" ? { ...storyAcc, story: entry.parentName } : key === \"moduleExport\" || typeof value == \"function\" ? storyAcc : Array.isArray(value) ? Object.assign(storyAcc, { [key]: value.slice().sort() }) : Object.assign(storyAcc, { [key]: value }),\n          {\n            args: story.initialArgs,\n            globals: {\n              ...this.userGlobals.initialGlobals,\n              ...this.userGlobals.globals,\n              ...story.storyGlobals\n            },\n            storyId: entry.parent ? entry.parent : storyId\n          }\n        )), acc;\n      },\n      {}\n    );\n    return console.log(\"extract: stories\", stories), stories;\n  }\n};\n\n// src/preview-api/modules/store/autoTitle.ts\nimport { once as once2 } from \"storybook/internal/client-logger\";\n\n// ../../node_modules/slash/index.js\nfunction slash(path) {\n  return path.startsWith(\"\\\\\\\\?\\\\\") ? path : path.replace(/\\\\/g, \"/\");\n}\n\n// src/preview-api/modules/store/autoTitle.ts\nvar sanitize2 = (parts) => {\n  if (parts.length === 0)\n    return parts;\n  let last = parts[parts.length - 1], lastStripped = last?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, \"\");\n  if (parts.length === 1)\n    return [lastStripped];\n  let nextToLast = parts[parts.length - 2];\n  return lastStripped && nextToLast && lastStripped.toLowerCase() === nextToLast.toLowerCase() ? [...parts.slice(0, -2), lastStripped] : lastStripped && (/^(story|stories)([.][^.]+)$/i.test(last) || /^index$/i.test(lastStripped)) ? parts.slice(0, -1) : [...parts.slice(0, -1), lastStripped];\n};\nfunction pathJoin(paths) {\n  return paths.flatMap((p) => p.split(\"/\")).filter(Boolean).join(\"/\");\n}\nvar userOrAutoTitleFromSpecifier = (fileName, entry, userTitle) => {\n  let { directory, importPathMatcher, titlePrefix = \"\" } = entry || {};\n  typeof fileName == \"number\" && once2.warn(dedent`\n      CSF Auto-title received a numeric fileName. This typically happens when\n      webpack is mis-configured in production mode. To force webpack to produce\n      filenames, set optimization.moduleIds = \"named\" in your webpack config.\n    `);\n  let normalizedFileName = slash(String(fileName));\n  if (importPathMatcher.exec(normalizedFileName)) {\n    if (!userTitle) {\n      let suffix = normalizedFileName.replace(directory, \"\"), parts = pathJoin([titlePrefix, suffix]).split(\"/\");\n      return parts = sanitize2(parts), parts.join(\"/\");\n    }\n    return titlePrefix ? pathJoin([titlePrefix, userTitle]) : userTitle;\n  }\n}, userOrAutoTitle = (fileName, storiesEntries, userTitle) => {\n  for (let i = 0; i < storiesEntries.length; i += 1) {\n    let title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i], userTitle);\n    if (title)\n      return title;\n  }\n  return userTitle || void 0;\n};\n\n// src/preview-api/modules/store/storySort.ts\nvar STORY_KIND_PATH_SEPARATOR = /\\s*\\/\\s*/, storySort = (options = {}) => (a, b) => {\n  if (a.title === b.title && !options.includeNames)\n    return 0;\n  let method = options.method || \"configure\", order = options.order || [], storyTitleA = a.title.trim().split(STORY_KIND_PATH_SEPARATOR), storyTitleB = b.title.trim().split(STORY_KIND_PATH_SEPARATOR);\n  options.includeNames && (storyTitleA.push(a.name), storyTitleB.push(b.name));\n  let depth = 0;\n  for (; storyTitleA[depth] || storyTitleB[depth]; ) {\n    if (!storyTitleA[depth])\n      return -1;\n    if (!storyTitleB[depth])\n      return 1;\n    let nameA = storyTitleA[depth], nameB = storyTitleB[depth];\n    if (nameA !== nameB) {\n      let indexA = order.indexOf(nameA), indexB = order.indexOf(nameB), indexWildcard = order.indexOf(\"*\");\n      return indexA !== -1 || indexB !== -1 ? (indexA === -1 && (indexWildcard !== -1 ? indexA = indexWildcard : indexA = order.length), indexB === -1 && (indexWildcard !== -1 ? indexB = indexWildcard : indexB = order.length), indexA - indexB) : method === \"configure\" ? 0 : nameA.localeCompare(nameB, options.locales ? options.locales : void 0, {\n        numeric: !0,\n        sensitivity: \"accent\"\n      });\n    }\n    let index = order.indexOf(nameA);\n    index === -1 && (index = order.indexOf(\"*\")), order = index !== -1 && Array.isArray(order[index + 1]) ? order[index + 1] : [], depth += 1;\n  }\n  return 0;\n};\n\n// src/preview-api/modules/store/sortStories.ts\nvar sortStoriesCommon = (stories, storySortParameter, fileNameOrder) => {\n  if (storySortParameter) {\n    let sortFn;\n    typeof storySortParameter == \"function\" ? sortFn = storySortParameter : sortFn = storySort(storySortParameter), stories.sort(sortFn);\n  } else\n    stories.sort(\n      (s1, s2) => fileNameOrder.indexOf(s1.importPath) - fileNameOrder.indexOf(s2.importPath)\n    );\n  return stories;\n}, sortStoriesV7 = (stories, storySortParameter, fileNameOrder) => {\n  try {\n    return sortStoriesCommon(stories, storySortParameter, fileNameOrder);\n  } catch (err) {\n    throw new Error(dedent`\n    Error sorting stories with sort parameter ${storySortParameter}:\n\n    > ${err.message}\n\n    Are you using a V6-style sort function in V7 mode?\n\n    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort\n  `);\n  }\n};\n\n// src/preview-api/modules/preview-web/Preview.tsx\nimport { deprecate as deprecate2, logger as logger7 } from \"storybook/internal/client-logger\";\nimport {\n  ARGTYPES_INFO_REQUEST,\n  ARGTYPES_INFO_RESPONSE,\n  CONFIG_ERROR,\n  FORCE_REMOUNT,\n  FORCE_RE_RENDER as FORCE_RE_RENDER2,\n  GLOBALS_UPDATED,\n  PREVIEW_INITIALIZED,\n  RESET_STORY_ARGS as RESET_STORY_ARGS2,\n  SET_GLOBALS,\n  STORY_ARGS_UPDATED,\n  STORY_HOT_UPDATED,\n  STORY_INDEX_INVALIDATED,\n  UPDATE_GLOBALS as UPDATE_GLOBALS2,\n  UPDATE_STORY_ARGS as UPDATE_STORY_ARGS2\n} from \"storybook/internal/core-events\";\nimport {\n  CalledPreviewMethodBeforeInitializationError,\n  MissingRenderToCanvasError,\n  StoryIndexFetchError,\n  StoryStoreAccessedBeforeInitializationError\n} from \"storybook/internal/preview-errors\";\nimport { global as global5 } from \"@storybook/global\";\n\n// src/preview-api/modules/preview-web/render/StoryRender.ts\nimport {\n  PLAY_FUNCTION_THREW_EXCEPTION,\n  STORY_FINISHED,\n  STORY_RENDERED as STORY_RENDERED2,\n  STORY_RENDER_PHASE_CHANGED,\n  UNHANDLED_ERRORS_WHILE_PLAYING\n} from \"storybook/internal/core-events\";\nimport {\n  MountMustBeDestructuredError as MountMustBeDestructuredError2,\n  NoStoryMountedError\n} from \"storybook/internal/preview-errors\";\n\n// src/preview-api/modules/preview-web/render/Render.ts\nvar PREPARE_ABORTED = new Error(\"prepareAborted\");\n\n// src/preview-api/modules/preview-web/render/StoryRender.ts\nvar { AbortController: AbortController2 } = globalThis;\nfunction serializeError(error) {\n  try {\n    let { name = \"Error\", message = String(error), stack } = error;\n    return { name, message, stack };\n  } catch {\n    return { name: \"Error\", message: String(error) };\n  }\n}\nvar StoryRender = class {\n  constructor(channel, store, renderToScreen, callbacks, id, viewMode, renderOptions = { autoplay: !0, forceInitialArgs: !1 }, story) {\n    this.channel = channel;\n    this.store = store;\n    this.renderToScreen = renderToScreen;\n    this.callbacks = callbacks;\n    this.id = id;\n    this.viewMode = viewMode;\n    this.renderOptions = renderOptions;\n    this.type = \"story\";\n    this.notYetRendered = !0;\n    this.rerenderEnqueued = !1;\n    this.disableKeyListeners = !1;\n    this.teardownRender = () => {\n    };\n    this.torndown = !1;\n    this.abortController = new AbortController2(), this.renderId = Date.now(), story && (this.story = story, this.phase = \"preparing\");\n  }\n  async runPhase(signal, phase, phaseFn) {\n    this.phase = phase, this.channel.emit(STORY_RENDER_PHASE_CHANGED, {\n      newPhase: this.phase,\n      renderId: this.renderId,\n      storyId: this.id\n    }), phaseFn && (await phaseFn(), this.checkIfAborted(signal));\n  }\n  checkIfAborted(signal) {\n    return signal.aborted && ![\"finished\", \"aborted\", \"errored\"].includes(this.phase) && (this.phase = \"aborted\", this.channel.emit(STORY_RENDER_PHASE_CHANGED, {\n      newPhase: this.phase,\n      renderId: this.renderId,\n      storyId: this.id\n    })), signal.aborted;\n  }\n  async prepare() {\n    if (await this.runPhase(this.abortController.signal, \"preparing\", async () => {\n      this.story = await this.store.loadStory({ storyId: this.id });\n    }), this.abortController.signal.aborted)\n      throw await this.store.cleanupStory(this.story), PREPARE_ABORTED;\n  }\n  // The two story \"renders\" are equal and have both loaded the same story\n  isEqual(other) {\n    return !!(this.id === other.id && this.story && this.story === other.story);\n  }\n  isPreparing() {\n    return [\"preparing\"].includes(this.phase);\n  }\n  isPending() {\n    return [\"loading\", \"beforeEach\", \"rendering\", \"playing\", \"afterEach\"].includes(\n      this.phase\n    );\n  }\n  async renderToElement(canvasElement) {\n    return this.canvasElement = canvasElement, this.render({ initial: !0, forceRemount: !0 });\n  }\n  storyContext() {\n    if (!this.story)\n      throw new Error(\"Cannot call storyContext before preparing\");\n    let { forceInitialArgs } = this.renderOptions;\n    return this.store.getStoryContext(this.story, { forceInitialArgs });\n  }\n  async render({\n    initial = !1,\n    forceRemount = !1\n  } = {}) {\n    let { canvasElement } = this;\n    if (!this.story)\n      throw new Error(\"cannot render when not prepared\");\n    let story = this.story;\n    if (!canvasElement)\n      throw new Error(\"cannot render when canvasElement is unset\");\n    let {\n      id,\n      componentId,\n      title,\n      name,\n      tags,\n      applyLoaders,\n      applyBeforeEach,\n      applyAfterEach,\n      unboundStoryFn,\n      playFunction,\n      runStep\n    } = story;\n    forceRemount && !initial && (this.cancelRender(), this.abortController = new AbortController2());\n    let abortSignal = this.abortController.signal, mounted = !1, isMountDestructured = story.usesMount;\n    try {\n      let context = {\n        ...this.storyContext(),\n        viewMode: this.viewMode,\n        abortSignal,\n        canvasElement,\n        loaded: {},\n        step: (label, play) => runStep(label, play, context),\n        context: null,\n        canvas: {},\n        userEvent: {},\n        renderToCanvas: async () => {\n          let teardown = await this.renderToScreen(renderContext, canvasElement);\n          this.teardownRender = teardown || (() => {\n          }), mounted = !0;\n        },\n        // The story provides (set in a renderer) a mount function that is a higher order function\n        // (context) => (...args) => Canvas\n        //\n        // Before assigning it to the context, we resolve the context dependency,\n        // so that a user can just call it as await mount(...args) in their play function.\n        mount: async (...args) => {\n          this.callbacks.showStoryDuringRender?.();\n          let mountReturn = null;\n          return await this.runPhase(abortSignal, \"rendering\", async () => {\n            mountReturn = await story.mount(context)(...args);\n          }), isMountDestructured && await this.runPhase(abortSignal, \"playing\"), mountReturn;\n        }\n      };\n      context.context = context;\n      let renderContext = {\n        componentId,\n        title,\n        kind: title,\n        id,\n        name,\n        story: name,\n        tags,\n        ...this.callbacks,\n        showError: (error) => (this.phase = \"errored\", this.callbacks.showError(error)),\n        showException: (error) => (this.phase = \"errored\", this.callbacks.showException(error)),\n        forceRemount: forceRemount || this.notYetRendered,\n        storyContext: context,\n        storyFn: () => unboundStoryFn(context),\n        unboundStoryFn\n      };\n      if (await this.runPhase(abortSignal, \"loading\", async () => {\n        context.loaded = await applyLoaders(context);\n      }), abortSignal.aborted)\n        return;\n      let cleanupCallbacks = await applyBeforeEach(context);\n      if (this.store.addCleanupCallbacks(story, ...cleanupCallbacks), this.checkIfAborted(abortSignal) || (!mounted && !isMountDestructured && await context.mount(), this.notYetRendered = !1, abortSignal.aborted))\n        return;\n      let ignoreUnhandledErrors = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === !0, unhandledErrors = /* @__PURE__ */ new Set(), onError = (event) => {\n        event.error && unhandledErrors.add(event.error);\n      }, onUnhandledRejection = (event) => {\n        event.reason && unhandledErrors.add(event.reason);\n      };\n      if (this.renderOptions.autoplay && forceRemount && playFunction && this.phase !== \"errored\") {\n        window?.addEventListener?.(\"error\", onError), window?.addEventListener?.(\"unhandledrejection\", onUnhandledRejection), this.disableKeyListeners = !0;\n        try {\n          if (isMountDestructured ? await playFunction(context) : (context.mount = async () => {\n            throw new MountMustBeDestructuredError2({ playFunction: playFunction.toString() });\n          }, await this.runPhase(abortSignal, \"playing\", async () => playFunction(context))), !mounted)\n            throw new NoStoryMountedError();\n          this.checkIfAborted(abortSignal), !ignoreUnhandledErrors && unhandledErrors.size > 0 ? await this.runPhase(abortSignal, \"errored\") : await this.runPhase(abortSignal, \"played\");\n        } catch (error) {\n          if (this.callbacks.showStoryDuringRender?.(), await this.runPhase(abortSignal, \"errored\", async () => {\n            this.channel.emit(PLAY_FUNCTION_THREW_EXCEPTION, serializeError(error));\n          }), this.story.parameters.throwPlayFunctionExceptions !== !1)\n            throw error;\n          console.error(error);\n        }\n        if (!ignoreUnhandledErrors && unhandledErrors.size > 0 && this.channel.emit(\n          UNHANDLED_ERRORS_WHILE_PLAYING,\n          Array.from(unhandledErrors).map(serializeError)\n        ), this.disableKeyListeners = !1, window?.removeEventListener?.(\"unhandledrejection\", onUnhandledRejection), window?.removeEventListener?.(\"error\", onError), abortSignal.aborted)\n          return;\n      }\n      await this.runPhase(abortSignal, \"completing\", async () => {\n        isTestEnvironment() ? this.store.addCleanupCallbacks(story, pauseAnimations()) : await waitForAnimations(abortSignal);\n      }), await this.runPhase(abortSignal, \"completed\", async () => {\n        this.channel.emit(STORY_RENDERED2, id);\n      }), this.phase !== \"errored\" && await this.runPhase(abortSignal, \"afterEach\", async () => {\n        await applyAfterEach(context);\n      });\n      let hasUnhandledErrors = !ignoreUnhandledErrors && unhandledErrors.size > 0, hasSomeReportsFailed = context.reporting.reports.some(\n        (report) => report.status === \"failed\"\n      ), hasStoryErrored = hasUnhandledErrors || hasSomeReportsFailed;\n      await this.runPhase(\n        abortSignal,\n        \"finished\",\n        async () => this.channel.emit(STORY_FINISHED, {\n          storyId: id,\n          status: hasStoryErrored ? \"error\" : \"success\",\n          reporters: context.reporting.reports\n        })\n      );\n    } catch (err) {\n      this.phase = \"errored\", this.callbacks.showException(err), await this.runPhase(\n        abortSignal,\n        \"finished\",\n        async () => this.channel.emit(STORY_FINISHED, {\n          storyId: id,\n          status: \"error\",\n          reporters: []\n        })\n      );\n    }\n    this.rerenderEnqueued && (this.rerenderEnqueued = !1, this.render());\n  }\n  /**\n   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be\n   * enqueued, and will be executed after the current render is completed. Rerendering while playing\n   * will not be enqueued, and will be executed immediately, to support rendering args changes while\n   * playing.\n   */\n  async rerender() {\n    if (this.isPending() && this.phase !== \"playing\")\n      this.rerenderEnqueued = !0;\n    else\n      return this.render();\n  }\n  async remount() {\n    return await this.teardown(), this.render({ forceRemount: !0 });\n  }\n  // If the story is torn down (either a new story is rendered or the docs page removes it)\n  // we need to consider the fact that the initial render may not be finished\n  // (possibly the loaders or the play function are still running). We use the controller\n  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what\n  // happens inside the user's code.\n  cancelRender() {\n    this.abortController.abort();\n  }\n  cancelPlayFunction() {\n    this.phase === \"playing\" && (this.abortController.abort(), this.runPhase(this.abortController.signal, \"aborted\"));\n  }\n  async teardown() {\n    this.torndown = !0, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);\n    for (let i = 0; i < 3; i += 1) {\n      if (!this.isPending()) {\n        await this.teardownRender();\n        return;\n      }\n      await new Promise((resolve) => setTimeout(resolve, 0));\n    }\n    window?.location?.reload?.(), await new Promise(() => {\n    });\n  }\n};\n\n// src/preview-api/modules/preview-web/Preview.tsx\nvar { fetch } = global5, STORY_INDEX_PATH = \"./index.json\", Preview = class {\n  constructor(importFn, getProjectAnnotations, channel = addons.getChannel(), shouldInitialize = !0) {\n    this.importFn = importFn;\n    this.getProjectAnnotations = getProjectAnnotations;\n    this.channel = channel;\n    this.storyRenders = [];\n    this.storeInitializationPromise = new Promise((resolve, reject) => {\n      this.resolveStoreInitializationPromise = resolve, this.rejectStoreInitializationPromise = reject;\n    }), shouldInitialize && this.initialize();\n  }\n  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`\n  // That proxies through to the store once ready, and errors beforehand. This means we can set\n  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and\n  // similarly integrators can access the `storyStore` on the preview at any time, although\n  // it is considered deprecated and we will no longer allow access in 9.0\n  get storyStore() {\n    return new Proxy(\n      {},\n      {\n        get: (_, method) => {\n          if (this.storyStoreValue)\n            return deprecate2(\"Accessing the Story Store is deprecated and will be removed in 9.0\"), this.storyStoreValue[method];\n          throw new StoryStoreAccessedBeforeInitializationError();\n        }\n      }\n    );\n  }\n  // INITIALIZATION\n  async initialize() {\n    this.setupListeners();\n    try {\n      let projectAnnotations = await this.getProjectAnnotationsOrRenderError();\n      await this.runBeforeAllHook(projectAnnotations), await this.initializeWithProjectAnnotations(projectAnnotations);\n      let userAgent = globalThis?.navigator?.userAgent;\n      await this.channel.emit(PREVIEW_INITIALIZED, { userAgent });\n    } catch (err) {\n      this.rejectStoreInitializationPromise(err);\n    }\n  }\n  ready() {\n    return this.storeInitializationPromise;\n  }\n  setupListeners() {\n    this.channel.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this)), this.channel.on(UPDATE_GLOBALS2, this.onUpdateGlobals.bind(this)), this.channel.on(UPDATE_STORY_ARGS2, this.onUpdateArgs.bind(this)), this.channel.on(ARGTYPES_INFO_REQUEST, this.onRequestArgTypesInfo.bind(this)), this.channel.on(RESET_STORY_ARGS2, this.onResetArgs.bind(this)), this.channel.on(FORCE_RE_RENDER2, this.onForceReRender.bind(this)), this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this)), this.channel.on(STORY_HOT_UPDATED, this.onStoryHotUpdated.bind(this));\n  }\n  async getProjectAnnotationsOrRenderError() {\n    try {\n      let projectAnnotations = await this.getProjectAnnotations();\n      if (this.renderToCanvas = projectAnnotations.renderToCanvas, !this.renderToCanvas)\n        throw new MissingRenderToCanvasError();\n      return projectAnnotations;\n    } catch (err) {\n      throw this.renderPreviewEntryError(\"Error reading preview.js:\", err), err;\n    }\n  }\n  // If initialization gets as far as project annotations, this function runs.\n  async initializeWithProjectAnnotations(projectAnnotations) {\n    this.projectAnnotationsBeforeInitialization = projectAnnotations;\n    try {\n      let storyIndex = await this.getStoryIndexFromServer();\n      return this.initializeWithStoryIndex(storyIndex);\n    } catch (err) {\n      throw this.renderPreviewEntryError(\"Error loading story index:\", err), err;\n    }\n  }\n  async runBeforeAllHook(projectAnnotations) {\n    try {\n      await this.beforeAllCleanup?.(), this.beforeAllCleanup = await projectAnnotations.beforeAll?.();\n    } catch (err) {\n      throw this.renderPreviewEntryError(\"Error in beforeAll hook:\", err), err;\n    }\n  }\n  async getStoryIndexFromServer() {\n    let result = await fetch(STORY_INDEX_PATH);\n    if (result.status === 200)\n      return result.json();\n    throw new StoryIndexFetchError({ text: await result.text() });\n  }\n  // If initialization gets as far as the story index, this function runs.\n  initializeWithStoryIndex(storyIndex) {\n    if (!this.projectAnnotationsBeforeInitialization)\n      throw new Error(\"Cannot call initializeWithStoryIndex until project annotations resolve\");\n    this.storyStoreValue = new StoryStore(\n      storyIndex,\n      this.importFn,\n      this.projectAnnotationsBeforeInitialization\n    ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();\n  }\n  async setInitialGlobals() {\n    this.emitGlobals();\n  }\n  emitGlobals() {\n    if (!this.storyStoreValue)\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"emitGlobals\" });\n    let payload = {\n      globals: this.storyStoreValue.userGlobals.get() || {},\n      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}\n    };\n    this.channel.emit(SET_GLOBALS, payload);\n  }\n  // EVENT HANDLERS\n  // This happens when a config file gets reloaded\n  async onGetProjectAnnotationsChanged({\n    getProjectAnnotations\n  }) {\n    delete this.previewEntryError, this.getProjectAnnotations = getProjectAnnotations;\n    let projectAnnotations = await this.getProjectAnnotationsOrRenderError();\n    if (await this.runBeforeAllHook(projectAnnotations), !this.storyStoreValue) {\n      await this.initializeWithProjectAnnotations(projectAnnotations);\n      return;\n    }\n    this.storyStoreValue.setProjectAnnotations(projectAnnotations), this.emitGlobals();\n  }\n  async onStoryIndexChanged() {\n    if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))\n      try {\n        let storyIndex = await this.getStoryIndexFromServer();\n        if (this.projectAnnotationsBeforeInitialization) {\n          this.initializeWithStoryIndex(storyIndex);\n          return;\n        }\n        await this.onStoriesChanged({ storyIndex });\n      } catch (err) {\n        throw this.renderPreviewEntryError(\"Error loading story index:\", err), err;\n      }\n  }\n  // This happens when a glob gets HMR-ed\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    if (!this.storyStoreValue)\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"onStoriesChanged\" });\n    await this.storyStoreValue.onStoriesChanged({ importFn, storyIndex });\n  }\n  async onUpdateGlobals({\n    globals: updatedGlobals,\n    currentStory\n  }) {\n    if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"onUpdateGlobals\" });\n    if (this.storyStoreValue.userGlobals.update(updatedGlobals), currentStory) {\n      let { initialGlobals, storyGlobals, userGlobals, globals } = this.storyStoreValue.getStoryContext(currentStory);\n      this.channel.emit(GLOBALS_UPDATED, {\n        initialGlobals,\n        userGlobals,\n        storyGlobals,\n        globals\n      });\n    } else {\n      let { initialGlobals, globals } = this.storyStoreValue.userGlobals;\n      this.channel.emit(GLOBALS_UPDATED, {\n        initialGlobals,\n        userGlobals: globals,\n        storyGlobals: {},\n        globals\n      });\n    }\n    await Promise.all(this.storyRenders.map((r) => r.rerender()));\n  }\n  async onUpdateArgs({ storyId, updatedArgs }) {\n    if (!this.storyStoreValue)\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"onUpdateArgs\" });\n    this.storyStoreValue.args.update(storyId, updatedArgs), await Promise.all(\n      this.storyRenders.filter((r) => r.id === storyId && !r.renderOptions.forceInitialArgs).map(\n        (r) => (\n          // We only run the play function, with in a force remount.\n          // But when mount is destructured, the rendering happens inside of the play function.\n          r.story && r.story.usesMount ? r.remount() : r.rerender()\n        )\n      )\n    ), this.channel.emit(STORY_ARGS_UPDATED, {\n      storyId,\n      args: this.storyStoreValue.args.get(storyId)\n    });\n  }\n  async onRequestArgTypesInfo({ id, payload }) {\n    try {\n      await this.storeInitializationPromise;\n      let story = await this.storyStoreValue?.loadStory(payload);\n      this.channel.emit(ARGTYPES_INFO_RESPONSE, {\n        id,\n        success: !0,\n        payload: { argTypes: story?.argTypes || {} },\n        error: null\n      });\n    } catch (e) {\n      this.channel.emit(ARGTYPES_INFO_RESPONSE, {\n        id,\n        success: !1,\n        error: e?.message\n      });\n    }\n  }\n  async onResetArgs({ storyId, argNames }) {\n    if (!this.storyStoreValue)\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"onResetArgs\" });\n    let story = this.storyRenders.find((r) => r.id === storyId)?.story || await this.storyStoreValue.loadStory({ storyId }), updatedArgs = (argNames || [\n      .../* @__PURE__ */ new Set([\n        ...Object.keys(story.initialArgs),\n        ...Object.keys(this.storyStoreValue.args.get(storyId))\n      ])\n    ]).reduce((acc, argName) => (acc[argName] = story.initialArgs[argName], acc), {});\n    await this.onUpdateArgs({ storyId, updatedArgs });\n  }\n  // ForceReRender does not include a story id, so we simply must\n  // re-render all stories in case they are relevant\n  async onForceReRender() {\n    await Promise.all(this.storyRenders.map((r) => r.rerender()));\n  }\n  async onForceRemount({ storyId }) {\n    await Promise.all(this.storyRenders.filter((r) => r.id === storyId).map((r) => r.remount()));\n  }\n  async onStoryHotUpdated() {\n    await Promise.all(this.storyRenders.map((r) => r.cancelPlayFunction()));\n  }\n  // Used by docs to render a story to a given element\n  // Note this short-circuits the `prepare()` phase of the StoryRender,\n  // main to be consistent with the previous behaviour. In the future,\n  // we will change it to go ahead and load the story, which will end up being\n  // \"instant\", although async.\n  renderStoryToElement(story, element, callbacks, options) {\n    if (!this.renderToCanvas || !this.storyStoreValue)\n      throw new CalledPreviewMethodBeforeInitializationError({\n        methodName: \"renderStoryToElement\"\n      });\n    let render = new StoryRender(\n      this.channel,\n      this.storyStoreValue,\n      this.renderToCanvas,\n      callbacks,\n      story.id,\n      \"docs\",\n      options,\n      story\n    );\n    return render.renderToElement(element), this.storyRenders.push(render), async () => {\n      await this.teardownRender(render);\n    };\n  }\n  async teardownRender(render, { viewModeChanged } = {}) {\n    this.storyRenders = this.storyRenders.filter((r) => r !== render), await render?.teardown?.({ viewModeChanged });\n  }\n  // API\n  async loadStory({ storyId }) {\n    if (!this.storyStoreValue)\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"loadStory\" });\n    return this.storyStoreValue.loadStory({ storyId });\n  }\n  getStoryContext(story, { forceInitialArgs = !1 } = {}) {\n    if (!this.storyStoreValue)\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"getStoryContext\" });\n    return this.storyStoreValue.getStoryContext(story, { forceInitialArgs });\n  }\n  async extract(options) {\n    if (!this.storyStoreValue)\n      throw new CalledPreviewMethodBeforeInitializationError({ methodName: \"extract\" });\n    if (this.previewEntryError)\n      throw this.previewEntryError;\n    return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(options);\n  }\n  // UTILITIES\n  renderPreviewEntryError(reason, err) {\n    this.previewEntryError = err, logger7.error(reason), logger7.error(err), this.channel.emit(CONFIG_ERROR, err);\n  }\n};\n\n// src/preview-api/modules/preview-web/PreviewWeb.tsx\nimport { global as global8 } from \"@storybook/global\";\n\n// src/preview-api/modules/preview-web/PreviewWithSelection.tsx\nimport { logger as logger8 } from \"storybook/internal/client-logger\";\nimport {\n  CURRENT_STORY_WAS_SET,\n  DOCS_PREPARED,\n  GLOBALS_UPDATED as GLOBALS_UPDATED2,\n  PRELOAD_ENTRIES,\n  PREVIEW_KEYDOWN,\n  SET_CURRENT_STORY,\n  STORY_CHANGED,\n  STORY_ERRORED,\n  STORY_MISSING,\n  STORY_PREPARED,\n  STORY_RENDER_PHASE_CHANGED as STORY_RENDER_PHASE_CHANGED2,\n  STORY_SPECIFIED,\n  STORY_THREW_EXCEPTION,\n  STORY_UNCHANGED,\n  UPDATE_QUERY_PARAMS\n} from \"storybook/internal/core-events\";\nimport {\n  CalledPreviewMethodBeforeInitializationError as CalledPreviewMethodBeforeInitializationError2,\n  EmptyIndexError,\n  MdxFileWithNoCsfReferencesError,\n  NoStoryMatchError\n} from \"storybook/internal/preview-errors\";\n\n// src/preview-api/modules/preview-web/render/CsfDocsRender.ts\nimport { DOCS_RENDERED } from \"storybook/internal/core-events\";\n\n// src/preview-api/modules/preview-web/docs-context/DocsContext.ts\nimport { isStory as isStory3 } from \"storybook/internal/csf\";\nvar DocsContext = class {\n  constructor(channel, store, renderStoryToElement, csfFiles) {\n    this.channel = channel;\n    this.store = store;\n    this.renderStoryToElement = renderStoryToElement;\n    this.storyIdByName = (storyName) => {\n      let storyId = this.nameToStoryId.get(storyName);\n      if (storyId)\n        return storyId;\n      throw new Error(`No story found with that name: ${storyName}`);\n    };\n    this.componentStories = () => this.componentStoriesValue;\n    this.componentStoriesFromCSFFile = (csfFile) => this.store.componentStoriesFromCSFFile({ csfFile });\n    this.storyById = (storyId) => {\n      if (!storyId) {\n        if (!this.primaryStory)\n          throw new Error(\n            \"No primary story defined for docs entry. Did you forget to use `<Meta>`?\"\n          );\n        return this.primaryStory;\n      }\n      let csfFile = this.storyIdToCSFFile.get(storyId);\n      if (!csfFile)\n        throw new Error(`Called \\`storyById\\` for story that was never loaded: ${storyId}`);\n      return this.store.storyFromCSFFile({ storyId, csfFile });\n    };\n    this.getStoryContext = (story) => ({\n      ...this.store.getStoryContext(story),\n      loaded: {},\n      viewMode: \"docs\"\n    });\n    this.loadStory = (id) => this.store.loadStory({ storyId: id });\n    this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), csfFiles.forEach((csfFile, index) => {\n      this.referenceCSFFile(csfFile);\n    });\n  }\n  // This docs entry references this CSF file and can synchronously load the stories, as well\n  // as reference them by module export. If the CSF is part of the \"component\" stories, they\n  // can also be referenced by name and are in the componentStories list.\n  referenceCSFFile(csfFile) {\n    this.exportsToCSFFile.set(csfFile.moduleExports, csfFile), this.exportsToCSFFile.set(csfFile.moduleExports.default, csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {\n      let annotation = csfFile.stories[story.id];\n      this.storyIdToCSFFile.set(annotation.id, csfFile), this.exportToStory.set(annotation.moduleExport, story);\n    });\n  }\n  attachCSFFile(csfFile) {\n    if (!this.exportsToCSFFile.has(csfFile.moduleExports))\n      throw new Error(\"Cannot attach a CSF file that has not been referenced\");\n    if (this.attachedCSFFiles.has(csfFile))\n      return;\n    this.attachedCSFFiles.add(csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {\n      this.nameToStoryId.set(story.name, story.id), this.componentStoriesValue.push(story), this.primaryStory || (this.primaryStory = story);\n    });\n  }\n  referenceMeta(metaExports, attach) {\n    let resolved = this.resolveModuleExport(metaExports);\n    if (resolved.type !== \"meta\")\n      throw new Error(\n        \"<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?\"\n      );\n    attach && this.attachCSFFile(resolved.csfFile);\n  }\n  get projectAnnotations() {\n    let { projectAnnotations } = this.store;\n    if (!projectAnnotations)\n      throw new Error(\"Can't get projectAnnotations from DocsContext before they are initialized\");\n    return projectAnnotations;\n  }\n  resolveAttachedModuleExportType(moduleExportType) {\n    if (moduleExportType === \"story\") {\n      if (!this.primaryStory)\n        throw new Error(\n          \"No primary story attached to this docs file, did you forget to use <Meta of={} />?\"\n        );\n      return { type: \"story\", story: this.primaryStory };\n    }\n    if (this.attachedCSFFiles.size === 0)\n      throw new Error(\n        \"No CSF file attached to this docs file, did you forget to use <Meta of={} />?\"\n      );\n    let firstAttachedCSFFile = Array.from(this.attachedCSFFiles)[0];\n    if (moduleExportType === \"meta\")\n      return { type: \"meta\", csfFile: firstAttachedCSFFile };\n    let { component } = firstAttachedCSFFile.meta;\n    if (!component)\n      throw new Error(\n        \"Attached CSF file does not defined a component, did you forget to export one?\"\n      );\n    return { type: \"component\", component };\n  }\n  resolveModuleExport(moduleExportOrType) {\n    let csfFile = this.exportsToCSFFile.get(moduleExportOrType);\n    if (!csfFile && moduleExportOrType && typeof moduleExportOrType == \"object\" && \"default\" in moduleExportOrType && (csfFile = this.exportsToCSFFile.get(moduleExportOrType.default)), csfFile)\n      return { type: \"meta\", csfFile };\n    let story = this.exportToStory.get(\n      isStory3(moduleExportOrType) ? moduleExportOrType.input : moduleExportOrType\n    );\n    return story ? { type: \"story\", story } : { type: \"component\", component: moduleExportOrType };\n  }\n  resolveOf(moduleExportOrType, validTypes = []) {\n    let resolved;\n    if ([\"component\", \"meta\", \"story\"].includes(moduleExportOrType)) {\n      let type = moduleExportOrType;\n      resolved = this.resolveAttachedModuleExportType(type);\n    } else\n      resolved = this.resolveModuleExport(moduleExportOrType);\n    if (validTypes.length && !validTypes.includes(resolved.type)) {\n      let prettyType = resolved.type === \"component\" ? \"component or unknown\" : resolved.type;\n      throw new Error(dedent`Invalid value passed to the 'of' prop. The value was resolved to a '${prettyType}' type but the only types for this block are: ${validTypes.join(\n        \", \"\n      )}.\n        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?\n        - ... or vice versa?\n        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);\n    }\n    switch (resolved.type) {\n      case \"component\":\n        return {\n          ...resolved,\n          projectAnnotations: this.projectAnnotations\n        };\n      case \"meta\":\n        return {\n          ...resolved,\n          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: resolved.csfFile })\n        };\n      case \"story\":\n      default:\n        return resolved;\n    }\n  }\n};\n\n// src/preview-api/modules/preview-web/render/CsfDocsRender.ts\nvar CsfDocsRender = class {\n  constructor(channel, store, entry, callbacks) {\n    this.channel = channel;\n    this.store = store;\n    this.entry = entry;\n    this.callbacks = callbacks;\n    this.type = \"docs\";\n    this.subtype = \"csf\";\n    this.torndown = !1;\n    this.disableKeyListeners = !1;\n    this.preparing = !1;\n    this.id = entry.id, this.renderId = Date.now();\n  }\n  isPreparing() {\n    return this.preparing;\n  }\n  async prepare() {\n    this.preparing = !0;\n    let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);\n    if (this.torndown)\n      throw PREPARE_ABORTED;\n    let { importPath, title } = this.entry, primaryCsfFile = this.store.processCSFFileWithCache(\n      entryExports,\n      importPath,\n      title\n    ), primaryStoryId = Object.keys(primaryCsfFile.stories)[0];\n    this.story = this.store.storyFromCSFFile({ storyId: primaryStoryId, csfFile: primaryCsfFile }), this.csfFiles = [primaryCsfFile, ...csfFiles], this.preparing = !1;\n  }\n  isEqual(other) {\n    return !!(this.id === other.id && this.story && this.story === other.story);\n  }\n  docsContext(renderStoryToElement) {\n    if (!this.csfFiles)\n      throw new Error(\"Cannot render docs before preparing\");\n    let docsContext = new DocsContext(\n      this.channel,\n      this.store,\n      renderStoryToElement,\n      this.csfFiles\n    );\n    return this.csfFiles.forEach((csfFile) => docsContext.attachCSFFile(csfFile)), docsContext;\n  }\n  async renderToElement(canvasElement, renderStoryToElement) {\n    if (!this.story || !this.csfFiles)\n      throw new Error(\"Cannot render docs before preparing\");\n    let docsContext = this.docsContext(renderStoryToElement), { docs: docsParameter } = this.story.parameters || {};\n    if (!docsParameter)\n      throw new Error(\n        \"Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed\"\n      );\n    let renderer = await docsParameter.renderer(), { render } = renderer, renderDocs = async () => {\n      try {\n        await render(docsContext, docsParameter, canvasElement), this.channel.emit(DOCS_RENDERED, this.id);\n      } catch (err) {\n        this.callbacks.showException(err);\n      }\n    };\n    return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged }) => {\n      !viewModeChanged || !canvasElement || renderer.unmount(canvasElement);\n    }, renderDocs();\n  }\n  async teardown({ viewModeChanged } = {}) {\n    this.teardownRender?.({ viewModeChanged }), this.torndown = !0;\n  }\n};\n\n// src/preview-api/modules/preview-web/render/MdxDocsRender.ts\nimport { DOCS_RENDERED as DOCS_RENDERED2 } from \"storybook/internal/core-events\";\nvar MdxDocsRender = class {\n  constructor(channel, store, entry, callbacks) {\n    this.channel = channel;\n    this.store = store;\n    this.entry = entry;\n    this.callbacks = callbacks;\n    this.type = \"docs\";\n    this.subtype = \"mdx\";\n    this.torndown = !1;\n    this.disableKeyListeners = !1;\n    this.preparing = !1;\n    this.id = entry.id, this.renderId = Date.now();\n  }\n  isPreparing() {\n    return this.preparing;\n  }\n  async prepare() {\n    this.preparing = !0;\n    let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);\n    if (this.torndown)\n      throw PREPARE_ABORTED;\n    this.csfFiles = csfFiles, this.exports = entryExports, this.preparing = !1;\n  }\n  isEqual(other) {\n    return !!(this.id === other.id && this.exports && this.exports === other.exports);\n  }\n  docsContext(renderStoryToElement) {\n    if (!this.csfFiles)\n      throw new Error(\"Cannot render docs before preparing\");\n    return new DocsContext(\n      this.channel,\n      this.store,\n      renderStoryToElement,\n      this.csfFiles\n    );\n  }\n  async renderToElement(canvasElement, renderStoryToElement) {\n    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)\n      throw new Error(\"Cannot render docs before preparing\");\n    let docsContext = this.docsContext(renderStoryToElement), { docs } = this.store.projectAnnotations.parameters ?? {};\n    if (!docs)\n      throw new Error(\n        \"Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed\"\n      );\n    let docsParameter = { ...docs, page: this.exports.default }, renderer = await docs.renderer(), { render } = renderer, renderDocs = async () => {\n      try {\n        await render(docsContext, docsParameter, canvasElement), this.channel.emit(DOCS_RENDERED2, this.id);\n      } catch (err) {\n        this.callbacks.showException(err);\n      }\n    };\n    return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged } = {}) => {\n      !viewModeChanged || !canvasElement || (renderer.unmount(canvasElement), this.torndown = !0);\n    }, renderDocs();\n  }\n  async teardown({ viewModeChanged } = {}) {\n    this.teardownRender?.({ viewModeChanged }), this.torndown = !0;\n  }\n};\n\n// src/preview-api/modules/preview-web/PreviewWithSelection.tsx\nvar globalWindow = globalThis;\nfunction focusInInput(event) {\n  let target = event.composedPath && event.composedPath()[0] || event.target;\n  return /input|textarea/i.test(target.tagName) || target.getAttribute(\"contenteditable\") !== null;\n}\nfunction isMdxEntry({ tags }) {\n  return tags?.includes(Tag.UNATTACHED_MDX) || tags?.includes(Tag.ATTACHED_MDX);\n}\nfunction isStoryRender(r) {\n  return r.type === \"story\";\n}\nfunction isDocsRender(r) {\n  return r.type === \"docs\";\n}\nfunction isCsfDocsRender(r) {\n  return isDocsRender(r) && r.subtype === \"csf\";\n}\nvar PreviewWithSelection = class extends Preview {\n  constructor(importFn, getProjectAnnotations, selectionStore, view) {\n    super(importFn, getProjectAnnotations, void 0, !1);\n    this.importFn = importFn;\n    this.getProjectAnnotations = getProjectAnnotations;\n    this.selectionStore = selectionStore;\n    this.view = view;\n    this.initialize();\n  }\n  setupListeners() {\n    super.setupListeners(), globalWindow.onkeydown = this.onKeydown.bind(this), this.channel.on(SET_CURRENT_STORY, this.onSetCurrentStory.bind(this)), this.channel.on(UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this)), this.channel.on(PRELOAD_ENTRIES, this.onPreloadStories.bind(this));\n  }\n  async setInitialGlobals() {\n    if (!this.storyStoreValue)\n      throw new CalledPreviewMethodBeforeInitializationError2({ methodName: \"setInitialGlobals\" });\n    let { globals } = this.selectionStore.selectionSpecifier || {};\n    globals && this.storyStoreValue.userGlobals.updateFromPersisted(globals), this.emitGlobals();\n  }\n  // If initialization gets as far as the story index, this function runs.\n  async initializeWithStoryIndex(storyIndex) {\n    return await super.initializeWithStoryIndex(storyIndex), this.selectSpecifiedStory();\n  }\n  // Use the selection specifier to choose a story, then render it\n  async selectSpecifiedStory() {\n    if (!this.storyStoreValue)\n      throw new CalledPreviewMethodBeforeInitializationError2({\n        methodName: \"selectSpecifiedStory\"\n      });\n    if (this.selectionStore.selection) {\n      await this.renderSelection();\n      return;\n    }\n    if (!this.selectionStore.selectionSpecifier) {\n      this.renderMissingStory();\n      return;\n    }\n    let { storySpecifier, args } = this.selectionStore.selectionSpecifier, entry = this.storyStoreValue.storyIndex.entryFromSpecifier(storySpecifier);\n    if (!entry) {\n      storySpecifier === \"*\" ? this.renderStoryLoadingException(storySpecifier, new EmptyIndexError()) : this.renderStoryLoadingException(\n        storySpecifier,\n        new NoStoryMatchError({ storySpecifier: storySpecifier.toString() })\n      );\n      return;\n    }\n    let { id: storyId, type: viewMode } = entry;\n    this.selectionStore.setSelection({ storyId, viewMode }), this.channel.emit(STORY_SPECIFIED, this.selectionStore.selection), this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), await this.renderSelection({ persistedArgs: args });\n  }\n  // EVENT HANDLERS\n  // This happens when a config file gets reloaded\n  async onGetProjectAnnotationsChanged({\n    getProjectAnnotations\n  }) {\n    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations }), this.selectionStore.selection && this.renderSelection();\n  }\n  // This happens when a glob gets HMR-ed\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    await super.onStoriesChanged({ importFn, storyIndex }), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();\n  }\n  onKeydown(event) {\n    if (!this.storyRenders.find((r) => r.disableKeyListeners) && !focusInInput(event)) {\n      let { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode } = event;\n      this.channel.emit(PREVIEW_KEYDOWN, {\n        event: { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode }\n      });\n    }\n  }\n  async onSetCurrentStory(selection) {\n    this.selectionStore.setSelection({ viewMode: \"story\", ...selection }), await this.storeInitializationPromise, this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), this.renderSelection();\n  }\n  onUpdateQueryParams(queryParams) {\n    this.selectionStore.setQueryParams(queryParams);\n  }\n  async onUpdateGlobals({ globals }) {\n    let currentStory = this.currentRender instanceof StoryRender && this.currentRender.story || void 0;\n    super.onUpdateGlobals({ globals, currentStory }), (this.currentRender instanceof MdxDocsRender || this.currentRender instanceof CsfDocsRender) && await this.currentRender.rerender?.();\n  }\n  async onUpdateArgs({ storyId, updatedArgs }) {\n    super.onUpdateArgs({ storyId, updatedArgs });\n  }\n  async onPreloadStories({ ids }) {\n    await this.storeInitializationPromise, this.storyStoreValue && await Promise.allSettled(ids.map((id) => this.storyStoreValue?.loadEntry(id)));\n  }\n  // RENDERING\n  // We can either have:\n  // - a story selected in \"story\" viewMode,\n  //     in which case we render it to the root element, OR\n  // - a story selected in \"docs\" viewMode,\n  //     in which case we render the docsPage for that story\n  async renderSelection({ persistedArgs } = {}) {\n    let { renderToCanvas } = this;\n    if (!this.storyStoreValue || !renderToCanvas)\n      throw new CalledPreviewMethodBeforeInitializationError2({ methodName: \"renderSelection\" });\n    let { selection } = this.selectionStore;\n    if (!selection)\n      throw new Error(\"Cannot call renderSelection as no selection was made\");\n    let { storyId } = selection, entry;\n    try {\n      entry = await this.storyStoreValue.storyIdToEntry(storyId);\n    } catch (err) {\n      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(storyId, err);\n      return;\n    }\n    let storyIdChanged = this.currentSelection?.storyId !== storyId, viewModeChanged = this.currentRender?.type !== entry.type;\n    entry.type === \"story\" ? this.view.showPreparingStory({ immediate: viewModeChanged }) : this.view.showPreparingDocs({ immediate: viewModeChanged }), this.currentRender?.isPreparing() && await this.teardownRender(this.currentRender);\n    let render;\n    entry.type === \"story\" ? render = new StoryRender(\n      this.channel,\n      this.storyStoreValue,\n      renderToCanvas,\n      this.mainStoryCallbacks(storyId),\n      storyId,\n      \"story\"\n    ) : isMdxEntry(entry) ? render = new MdxDocsRender(\n      this.channel,\n      this.storyStoreValue,\n      entry,\n      this.mainStoryCallbacks(storyId)\n    ) : render = new CsfDocsRender(\n      this.channel,\n      this.storyStoreValue,\n      entry,\n      this.mainStoryCallbacks(storyId)\n    );\n    let lastSelection = this.currentSelection;\n    this.currentSelection = selection;\n    let lastRender = this.currentRender;\n    this.currentRender = render;\n    try {\n      await render.prepare();\n    } catch (err) {\n      lastRender && await this.teardownRender(lastRender), err !== PREPARE_ABORTED && this.renderStoryLoadingException(storyId, err);\n      return;\n    }\n    let implementationChanged = !storyIdChanged && lastRender && !render.isEqual(lastRender);\n    if (persistedArgs && isStoryRender(render) && (invariant(!!render.story), this.storyStoreValue.args.updateFromPersisted(render.story, persistedArgs)), lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {\n      this.currentRender = lastRender, this.channel.emit(STORY_UNCHANGED, storyId), this.view.showMain();\n      return;\n    }\n    if (lastRender && await this.teardownRender(lastRender, { viewModeChanged }), lastSelection && (storyIdChanged || viewModeChanged) && this.channel.emit(STORY_CHANGED, storyId), isStoryRender(render)) {\n      invariant(!!render.story);\n      let {\n        parameters,\n        initialArgs,\n        argTypes,\n        unmappedArgs,\n        initialGlobals,\n        userGlobals,\n        storyGlobals,\n        globals\n      } = this.storyStoreValue.getStoryContext(render.story);\n      this.channel.emit(STORY_PREPARED, {\n        id: storyId,\n        parameters,\n        initialArgs,\n        argTypes,\n        args: unmappedArgs\n      }), this.channel.emit(GLOBALS_UPDATED2, { userGlobals, storyGlobals, globals, initialGlobals });\n    } else {\n      let { parameters } = this.storyStoreValue.projectAnnotations, { initialGlobals, globals } = this.storyStoreValue.userGlobals;\n      if (this.channel.emit(GLOBALS_UPDATED2, {\n        globals,\n        initialGlobals,\n        storyGlobals: {},\n        userGlobals: globals\n      }), isCsfDocsRender(render) || render.entry.tags?.includes(Tag.ATTACHED_MDX)) {\n        if (!render.csfFiles)\n          throw new MdxFileWithNoCsfReferencesError({ storyId });\n        ({ parameters } = this.storyStoreValue.preparedMetaFromCSFFile({\n          csfFile: render.csfFiles[0]\n        }));\n      }\n      this.channel.emit(DOCS_PREPARED, {\n        id: storyId,\n        parameters\n      });\n    }\n    isStoryRender(render) ? (invariant(!!render.story), this.storyRenders.push(render), this.currentRender.renderToElement(\n      this.view.prepareForStory(render.story)\n    )) : this.currentRender.renderToElement(\n      this.view.prepareForDocs(),\n      // This argument is used for docs, which is currently only compatible with HTMLElements\n      this.renderStoryToElement.bind(this)\n    );\n  }\n  async teardownRender(render, { viewModeChanged = !1 } = {}) {\n    this.storyRenders = this.storyRenders.filter((r) => r !== render), await render?.teardown?.({ viewModeChanged });\n  }\n  // UTILITIES\n  mainStoryCallbacks(storyId) {\n    return {\n      showStoryDuringRender: () => this.view.showStoryDuringRender(),\n      showMain: () => this.view.showMain(),\n      showError: (err) => this.renderError(storyId, err),\n      showException: (err) => this.renderException(storyId, err)\n    };\n  }\n  renderPreviewEntryError(reason, err) {\n    super.renderPreviewEntryError(reason, err), this.view.showErrorDisplay(err);\n  }\n  renderMissingStory() {\n    this.view.showNoPreview(), this.channel.emit(STORY_MISSING);\n  }\n  renderStoryLoadingException(storySpecifier, err) {\n    logger8.error(err), this.view.showErrorDisplay(err), this.channel.emit(STORY_MISSING, storySpecifier);\n  }\n  // renderException is used if we fail to render the story and it is uncaught by the app layer\n  renderException(storyId, error) {\n    let { name = \"Error\", message = String(error), stack } = error, renderId = this.currentRender?.renderId;\n    this.channel.emit(STORY_THREW_EXCEPTION, { name, message, stack }), this.channel.emit(STORY_RENDER_PHASE_CHANGED2, { newPhase: \"errored\", renderId, storyId }), this.view.showErrorDisplay(error), logger8.error(`Error rendering story '${storyId}':`), logger8.error(error);\n  }\n  // renderError is used by the various app layers to inform the user they have done something\n  // wrong -- for instance returned the wrong thing from a story\n  renderError(storyId, { title, description }) {\n    let renderId = this.currentRender?.renderId;\n    this.channel.emit(STORY_ERRORED, { title, description }), this.channel.emit(STORY_RENDER_PHASE_CHANGED2, { newPhase: \"errored\", renderId, storyId }), this.view.showErrorDisplay({ message: title, stack: description }), logger8.error(`Error rendering story ${title}: ${description}`);\n  }\n};\n\n// src/preview-api/modules/preview-web/UrlStore.ts\nvar import_picoquery2 = __toESM(require_main(), 1);\nimport { global as global6 } from \"@storybook/global\";\n\n// src/preview-api/modules/preview-web/parseArgsParam.ts\nimport { once as once3 } from \"storybook/internal/client-logger\";\nvar import_picoquery = __toESM(require_main(), 1);\nvar VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/, NUMBER_REGEXP = /^-?[0-9]+(\\.[0-9]+)?$/, HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i, COLOR_REGEXP = /^(rgba?|hsla?)\\(([0-9]{1,3}),\\s?([0-9]{1,3})%?,\\s?([0-9]{1,3})%?,?\\s?([0-9](\\.[0-9]{1,2})?)?\\)$/i, validateArgs = (key = \"\", value) => key === null || key === \"\" || !VALIDATION_REGEXP.test(key) ? !1 : value == null || value instanceof Date || typeof value == \"number\" || typeof value == \"boolean\" ? !0 : typeof value == \"string\" ? VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value) : Array.isArray(value) ? value.every((v) => validateArgs(key, v)) : isPlainObject(value) ? Object.entries(value).every(([k, v]) => validateArgs(k, v)) : !1, QUERY_OPTIONS = {\n  delimiter: \";\",\n  // we're parsing a single query param\n  nesting: !0,\n  arrayRepeat: !0,\n  arrayRepeatSyntax: \"bracket\",\n  nestingSyntax: \"js\",\n  // objects are encoded using dot notation\n  valueDeserializer(str) {\n    if (str.startsWith(\"!\")) {\n      if (str === \"!undefined\")\n        return;\n      if (str === \"!null\")\n        return null;\n      if (str === \"!true\")\n        return !0;\n      if (str === \"!false\")\n        return !1;\n      if (str.startsWith(\"!date(\") && str.endsWith(\")\"))\n        return new Date(str.replaceAll(\" \", \"+\").slice(6, -1));\n      if (str.startsWith(\"!hex(\") && str.endsWith(\")\"))\n        return `#${str.slice(5, -1)}`;\n      let color = str.slice(1).match(COLOR_REGEXP);\n      if (color)\n        return str.startsWith(\"!rgba\") || str.startsWith(\"!RGBA\") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})` : str.startsWith(\"!hsla\") || str.startsWith(\"!HSLA\") ? `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})` : str.startsWith(\"!rgb\") || str.startsWith(\"!RGB\") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;\n    }\n    return NUMBER_REGEXP.test(str) ? Number(str) : str;\n  }\n}, parseArgsParam = (argsString) => {\n  let parts = argsString.split(\";\").map((part) => part.replace(\"=\", \"~\").replace(\":\", \"=\"));\n  return Object.entries((0, import_picoquery.parse)(parts.join(\";\"), QUERY_OPTIONS)).reduce((acc, [key, value]) => validateArgs(key, value) ? Object.assign(acc, { [key]: value }) : (once3.warn(dedent`\n      Omitted potentially unsafe URL args.\n\n      More info: https://storybook.js.org/docs/writing-stories/args?ref=error#setting-args-through-the-url\n    `), acc), {});\n};\n\n// src/preview-api/modules/preview-web/UrlStore.ts\nvar { history, document: document2 } = global6;\nfunction pathToId(path) {\n  let match = (path || \"\").match(/^\\/story\\/(.+)/);\n  if (!match)\n    throw new Error(`Invalid path '${path}',  must start with '/story/'`);\n  return match[1];\n}\nvar getQueryString = ({\n  selection,\n  extraParams\n}) => {\n  let search = document2?.location.search.slice(1), { path, selectedKind, selectedStory, ...rest } = (0, import_picoquery2.parse)(search);\n  return `?${(0, import_picoquery2.stringify)({\n    ...rest,\n    ...extraParams,\n    ...selection && { id: selection.storyId, viewMode: selection.viewMode }\n  })}`;\n}, setPath = (selection) => {\n  if (!selection)\n    return;\n  let query = getQueryString({ selection }), { hash = \"\" } = document2.location;\n  document2.title = selection.storyId, history.replaceState({}, \"\", `${document2.location.pathname}${query}${hash}`);\n}, isObject = (val) => val != null && typeof val == \"object\" && Array.isArray(val) === !1, getFirstString = (v) => {\n  if (v !== void 0) {\n    if (typeof v == \"string\")\n      return v;\n    if (Array.isArray(v))\n      return getFirstString(v[0]);\n    if (isObject(v))\n      return getFirstString(\n        Object.values(v).filter(Boolean)\n      );\n  }\n}, getSelectionSpecifierFromPath = () => {\n  if (typeof document2 < \"u\") {\n    let queryStr = document2.location.search.slice(1), query = (0, import_picoquery2.parse)(queryStr), args = typeof query.args == \"string\" ? parseArgsParam(query.args) : void 0, globals = typeof query.globals == \"string\" ? parseArgsParam(query.globals) : void 0, viewMode = getFirstString(query.viewMode);\n    if (typeof viewMode != \"string\" || !viewMode)\n      viewMode = \"story\";\n    else if (!viewMode.match(/docs|story/))\n      return null;\n    let path = getFirstString(query.path), storyId = path ? pathToId(path) : getFirstString(query.id);\n    if (storyId)\n      return { storySpecifier: storyId, args, globals, viewMode };\n  }\n  return null;\n}, UrlStore = class {\n  constructor() {\n    this.selectionSpecifier = getSelectionSpecifierFromPath();\n  }\n  setSelection(selection) {\n    this.selection = selection, setPath(this.selection);\n  }\n  setQueryParams(queryParams) {\n    let query = getQueryString({ extraParams: queryParams }), { hash = \"\" } = document2.location;\n    history.replaceState({}, \"\", `${document2.location.pathname}${query}${hash}`);\n  }\n};\n\n// src/preview-api/modules/preview-web/WebView.ts\nvar import_ansi_to_html = __toESM(require_ansi_to_html(), 1), import_picoquery3 = __toESM(require_main(), 1);\nimport { logger as logger9 } from \"storybook/internal/client-logger\";\nimport { global as global7 } from \"@storybook/global\";\nvar { document: document3 } = global7, PREPARING_DELAY = 100, Mode = /* @__PURE__ */ ((Mode2) => (Mode2.MAIN = \"MAIN\", Mode2.NOPREVIEW = \"NOPREVIEW\", Mode2.PREPARING_STORY = \"PREPARING_STORY\", Mode2.PREPARING_DOCS = \"PREPARING_DOCS\", Mode2.ERROR = \"ERROR\", Mode2))(Mode || {}), classes = {\n  PREPARING_STORY: \"sb-show-preparing-story\",\n  PREPARING_DOCS: \"sb-show-preparing-docs\",\n  MAIN: \"sb-show-main\",\n  NOPREVIEW: \"sb-show-nopreview\",\n  ERROR: \"sb-show-errordisplay\"\n}, layoutClassMap = {\n  centered: \"sb-main-centered\",\n  fullscreen: \"sb-main-fullscreen\",\n  padded: \"sb-main-padded\"\n}, ansiConverter = new import_ansi_to_html.default({\n  escapeXML: !0\n}), WebView = class {\n  constructor() {\n    this.testing = !1;\n    if (typeof document3 < \"u\") {\n      let { __SPECIAL_TEST_PARAMETER__ } = (0, import_picoquery3.parse)(document3.location.search.slice(1));\n      switch (__SPECIAL_TEST_PARAMETER__) {\n        case \"preparing-story\": {\n          this.showPreparingStory(), this.testing = !0;\n          break;\n        }\n        case \"preparing-docs\": {\n          this.showPreparingDocs(), this.testing = !0;\n          break;\n        }\n        default:\n      }\n    }\n  }\n  // Get ready to render a story, returning the element to render to\n  prepareForStory(story) {\n    return this.showStory(), this.applyLayout(story.parameters.layout), document3.documentElement.scrollTop = 0, document3.documentElement.scrollLeft = 0, this.storyRoot();\n  }\n  storyRoot() {\n    return document3.getElementById(\"storybook-root\");\n  }\n  prepareForDocs() {\n    return this.showMain(), this.showDocs(), this.applyLayout(\"fullscreen\"), document3.documentElement.scrollTop = 0, document3.documentElement.scrollLeft = 0, this.docsRoot();\n  }\n  docsRoot() {\n    return document3.getElementById(\"storybook-docs\");\n  }\n  applyLayout(layout = \"padded\") {\n    if (layout === \"none\") {\n      document3.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;\n      return;\n    }\n    this.checkIfLayoutExists(layout);\n    let layoutClass = layoutClassMap[layout];\n    document3.body.classList.remove(this.currentLayoutClass), document3.body.classList.add(layoutClass), this.currentLayoutClass = layoutClass;\n  }\n  checkIfLayoutExists(layout) {\n    layoutClassMap[layout] || logger9.warn(\n      dedent`\n          The desired layout: ${layout} is not a valid option.\n          The possible options are: ${Object.keys(layoutClassMap).join(\", \")}, none.\n        `\n    );\n  }\n  showMode(mode) {\n    clearTimeout(this.preparingTimeout), Object.keys(Mode).forEach((otherMode) => {\n      otherMode === mode ? document3.body.classList.add(classes[otherMode]) : document3.body.classList.remove(classes[otherMode]);\n    });\n  }\n  showErrorDisplay({ message = \"\", stack = \"\" }) {\n    let header = message, detail = stack, parts = message.split(`\n`);\n    parts.length > 1 && ([header] = parts, detail = parts.slice(1).join(`\n`).replace(/^\\n/, \"\")), document3.getElementById(\"error-message\").innerHTML = ansiConverter.toHtml(header), document3.getElementById(\"error-stack\").innerHTML = ansiConverter.toHtml(detail), this.showMode(\"ERROR\" /* ERROR */);\n  }\n  showNoPreview() {\n    this.testing || (this.showMode(\"NOPREVIEW\" /* NOPREVIEW */), this.storyRoot()?.setAttribute(\"hidden\", \"true\"), this.docsRoot()?.setAttribute(\"hidden\", \"true\"));\n  }\n  showPreparingStory({ immediate = !1 } = {}) {\n    clearTimeout(this.preparingTimeout), immediate ? this.showMode(\"PREPARING_STORY\" /* PREPARING_STORY */) : this.preparingTimeout = setTimeout(\n      () => this.showMode(\"PREPARING_STORY\" /* PREPARING_STORY */),\n      PREPARING_DELAY\n    );\n  }\n  showPreparingDocs({ immediate = !1 } = {}) {\n    clearTimeout(this.preparingTimeout), immediate ? this.showMode(\"PREPARING_DOCS\" /* PREPARING_DOCS */) : this.preparingTimeout = setTimeout(() => this.showMode(\"PREPARING_DOCS\" /* PREPARING_DOCS */), PREPARING_DELAY);\n  }\n  showMain() {\n    this.showMode(\"MAIN\" /* MAIN */);\n  }\n  showDocs() {\n    this.storyRoot().setAttribute(\"hidden\", \"true\"), this.docsRoot().removeAttribute(\"hidden\");\n  }\n  showStory() {\n    this.docsRoot().setAttribute(\"hidden\", \"true\"), this.storyRoot().removeAttribute(\"hidden\");\n  }\n  showStoryDuringRender() {\n    document3.body.classList.add(classes.MAIN);\n  }\n};\n\n// src/preview-api/modules/preview-web/PreviewWeb.tsx\nvar PreviewWeb = class extends PreviewWithSelection {\n  constructor(importFn, getProjectAnnotations) {\n    super(importFn, getProjectAnnotations, new UrlStore(), new WebView());\n    this.importFn = importFn;\n    this.getProjectAnnotations = getProjectAnnotations;\n    global8.__STORYBOOK_PREVIEW__ = this;\n  }\n};\n\n// src/preview-api/modules/preview-web/simulate-pageload.ts\nimport { global as global9 } from \"@storybook/global\";\nvar { document: document4 } = global9, runScriptTypes = [\n  \"application/javascript\",\n  \"application/ecmascript\",\n  \"application/x-ecmascript\",\n  \"application/x-javascript\",\n  \"text/ecmascript\",\n  \"text/javascript\",\n  \"text/javascript1.0\",\n  \"text/javascript1.1\",\n  \"text/javascript1.2\",\n  \"text/javascript1.3\",\n  \"text/javascript1.4\",\n  \"text/javascript1.5\",\n  \"text/jscript\",\n  \"text/livescript\",\n  \"text/x-ecmascript\",\n  \"text/x-javascript\",\n  // Support modern javascript\n  \"module\"\n], SCRIPT = \"script\", SCRIPTS_ROOT_ID = \"scripts-root\";\nfunction simulateDOMContentLoaded() {\n  let DOMContentLoadedEvent = document4.createEvent(\"Event\");\n  DOMContentLoadedEvent.initEvent(\"DOMContentLoaded\", !0, !0), document4.dispatchEvent(DOMContentLoadedEvent);\n}\nfunction insertScript($script, callback, $scriptRoot) {\n  let scriptEl = document4.createElement(\"script\");\n  scriptEl.type = $script.type === \"module\" ? \"module\" : \"text/javascript\", $script.src ? (scriptEl.onload = callback, scriptEl.onerror = callback, scriptEl.src = $script.src) : scriptEl.textContent = $script.innerText, $scriptRoot ? $scriptRoot.appendChild(scriptEl) : document4.head.appendChild(scriptEl), $script.parentNode.removeChild($script), $script.src || callback();\n}\nfunction insertScriptsSequentially(scriptsToExecute, callback, index = 0) {\n  scriptsToExecute[index](() => {\n    index++, index === scriptsToExecute.length ? callback() : insertScriptsSequentially(scriptsToExecute, callback, index);\n  });\n}\nfunction simulatePageLoad($container) {\n  let $scriptsRoot = document4.getElementById(SCRIPTS_ROOT_ID);\n  $scriptsRoot ? $scriptsRoot.innerHTML = \"\" : ($scriptsRoot = document4.createElement(\"div\"), $scriptsRoot.id = SCRIPTS_ROOT_ID, document4.body.appendChild($scriptsRoot));\n  let $scripts = Array.from($container.querySelectorAll(SCRIPT));\n  if ($scripts.length) {\n    let scriptsToExecute = [];\n    $scripts.forEach(($script) => {\n      let typeAttr = $script.getAttribute(\"type\");\n      (!typeAttr || runScriptTypes.includes(typeAttr)) && scriptsToExecute.push((callback) => insertScript($script, callback, $scriptsRoot));\n    }), scriptsToExecute.length && insertScriptsSequentially(scriptsToExecute, simulateDOMContentLoaded, void 0);\n  } else\n    simulateDOMContentLoaded();\n}\n\n// src/preview-api/modules/preview-web/emitTransformCode.ts\nasync function emitTransformCode(source, context) {\n  let transform = context.parameters?.docs?.source?.transform, { id, unmappedArgs } = context, transformed = transform && source ? transform?.(source, context) : source, result = transformed ? await transformed : void 0;\n  addons.getChannel().emit(SNIPPET_RENDERED, {\n    id,\n    source: result,\n    args: unmappedArgs\n  });\n}\n\nexport {\n  mockChannel,\n  addons,\n  HooksContext,\n  applyHooks,\n  useMemo,\n  useCallback,\n  useRef,\n  useState,\n  useReducer,\n  useEffect,\n  useChannel,\n  useStoryContext,\n  useParameter,\n  useArgs,\n  useGlobals,\n  makeDecorator,\n  combineArgs,\n  normalizeArrays,\n  normalizeStory,\n  mountDestructured,\n  decorateStory,\n  sanitizeStoryContextUpdate,\n  defaultDecorateStory,\n  prepareStory,\n  prepareMeta,\n  filterArgTypes,\n  inferControls,\n  normalizeProjectAnnotations,\n  composeStepRunners,\n  composeConfigs,\n  ReporterAPI,\n  getCsfFactoryAnnotations,\n  setDefaultProjectAnnotations,\n  setProjectAnnotations,\n  composeStory,\n  composeStories,\n  createPlaywrightTest,\n  StoryStore,\n  userOrAutoTitleFromSpecifier,\n  userOrAutoTitle,\n  sortStoriesV7,\n  Preview,\n  DocsContext,\n  PreviewWithSelection,\n  UrlStore,\n  WebView,\n  PreviewWeb,\n  simulateDOMContentLoaded,\n  simulatePageLoad,\n  emitTransformCode\n};\n","import {\n  DEFAULT_BACKGROUNDS,\n  PARAM_KEY as PARAM_KEY2,\n  PARAM_KEY2 as PARAM_KEY3,\n  PARAM_KEY3 as PARAM_KEY4\n} from \"../_browser-chunks/chunk-FNXWN6IK.js\";\nimport {\n  composeConfigs,\n  composeStory,\n  mountDestructured,\n  normalizeArrays,\n  normalizeProjectAnnotations\n} from \"../_browser-chunks/chunk-2N4WE3KZ.js\";\nimport \"../_browser-chunks/chunk-MEXTPDJG.js\";\nimport {\n  Tag\n} from \"../_browser-chunks/chunk-AFVOZMXQ.js\";\nimport \"../_browser-chunks/chunk-XLJZ7AOP.js\";\nimport {\n  combineParameters\n} from \"../_browser-chunks/chunk-SI6AKD4S.js\";\nimport \"../_browser-chunks/chunk-IYCKG66Y.js\";\nimport \"../_browser-chunks/chunk-NZMVUW5T.js\";\nimport {\n  invariant\n} from \"../_browser-chunks/chunk-IWQGIXJS.js\";\nimport \"../_browser-chunks/chunk-V2VKKSMQ.js\";\nimport \"../_browser-chunks/chunk-YK43Z22A.js\";\nimport \"../_browser-chunks/chunk-LCHBOIHN.js\";\nimport \"../_browser-chunks/chunk-ZCFV7BZB.js\";\nimport {\n  dedent\n} from \"../_browser-chunks/chunk-3LY4VQVK.js\";\nimport {\n  HIGHLIGHT,\n  MAX_Z_INDEX,\n  MIN_TOUCH_AREA_SIZE,\n  REMOVE_HIGHLIGHT,\n  RESET_HIGHLIGHT,\n  SCROLL_INTO_VIEW\n} from \"../_browser-chunks/chunk-KJHJLCBK.js\";\nimport \"../_browser-chunks/chunk-ECQ75MKQ.js\";\nimport {\n  action\n} from \"../_browser-chunks/chunk-EUVGDK4H.js\";\nimport \"../_browser-chunks/chunk-6XWLIJQL.js\";\nimport {\n  PARAM_KEY\n} from \"../_browser-chunks/chunk-SL75JR6Y.js\";\nimport {\n  __commonJS,\n  __export,\n  __toESM\n} from \"../_browser-chunks/chunk-A242L54C.js\";\n\n// ../../node_modules/@ngard/tiny-isequal/index.js\nvar require_tiny_isequal = __commonJS({\n  \"../../node_modules/@ngard/tiny-isequal/index.js\"(exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: !0 }), exports.isEqual = /* @__PURE__ */ (function() {\n      var e = Object.prototype.toString, r = Object.getPrototypeOf, t = Object.getOwnPropertySymbols ? function(e2) {\n        return Object.keys(e2).concat(Object.getOwnPropertySymbols(e2));\n      } : Object.keys;\n      return function(n, a) {\n        return (function n2(a2, c, u) {\n          var i, s, l, o = e.call(a2), f = e.call(c);\n          if (a2 === c) return !0;\n          if (a2 == null || c == null) return !1;\n          if (u.indexOf(a2) > -1 && u.indexOf(c) > -1) return !0;\n          if (u.push(a2, c), o != f || (i = t(a2), s = t(c), i.length != s.length || i.some(function(e2) {\n            return !n2(a2[e2], c[e2], u);\n          }))) return !1;\n          switch (o.slice(8, -1)) {\n            case \"Symbol\":\n              return a2.valueOf() == c.valueOf();\n            case \"Date\":\n            case \"Number\":\n              return +a2 == +c || +a2 != +a2 && +c != +c;\n            case \"RegExp\":\n            case \"Function\":\n            case \"String\":\n            case \"Boolean\":\n              return \"\" + a2 == \"\" + c;\n            case \"Set\":\n            case \"Map\":\n              i = a2.entries(), s = c.entries();\n              do\n                if (!n2((l = i.next()).value, s.next().value, u)) return !1;\n              while (!l.done);\n              return !0;\n            case \"ArrayBuffer\":\n              a2 = new Uint8Array(a2), c = new Uint8Array(c);\n            case \"DataView\":\n              a2 = new Uint8Array(a2.buffer), c = new Uint8Array(c.buffer);\n            case \"Float32Array\":\n            case \"Float64Array\":\n            case \"Int8Array\":\n            case \"Int16Array\":\n            case \"Int32Array\":\n            case \"Uint8Array\":\n            case \"Uint16Array\":\n            case \"Uint32Array\":\n            case \"Uint8ClampedArray\":\n            case \"Arguments\":\n            case \"Array\":\n              if (a2.length != c.length) return !1;\n              for (l = 0; l < a2.length; l++) if ((l in a2 || l in c) && (l in a2 != l in c || !n2(a2[l], c[l], u))) return !1;\n              return !0;\n            case \"Object\":\n              return n2(r(a2), r(c), u);\n            default:\n              return !1;\n          }\n        })(n, a, []);\n      };\n    })();\n  }\n});\n\n// src/csf/toStartCaseStr.ts\nfunction toStartCaseStr(str) {\n  return str.replace(/_/g, \" \").replace(/-/g, \" \").replace(/\\./g, \" \").replace(/([^\\n])([A-Z])([a-z])/g, (str2, $1, $2, $3) => `${$1} ${$2}${$3}`).replace(/([a-z])([A-Z])/g, (str2, $1, $2) => `${$1} ${$2}`).replace(/([a-z])([0-9])/gi, (str2, $1, $2) => `${$1} ${$2}`).replace(/([0-9])([a-z])/gi, (str2, $1, $2) => `${$1} ${$2}`).replace(/(\\s|^)(\\w)/g, (str2, $1, $2) => `${$1}${$2.toUpperCase()}`).replace(/ +/g, \" \").trim();\n}\n\n// src/csf/includeConditionalArg.ts\nvar import_tiny_isequal = __toESM(require_tiny_isequal(), 1), count = (vals) => vals.map((v) => typeof v < \"u\").filter(Boolean).length, testValue = (cond, value) => {\n  let { exists, eq, neq, truthy } = cond;\n  if (count([exists, eq, neq, truthy]) > 1)\n    throw new Error(`Invalid conditional test ${JSON.stringify({ exists, eq, neq })}`);\n  if (typeof eq < \"u\")\n    return (0, import_tiny_isequal.isEqual)(value, eq);\n  if (typeof neq < \"u\")\n    return !(0, import_tiny_isequal.isEqual)(value, neq);\n  if (typeof exists < \"u\") {\n    let valueExists = typeof value < \"u\";\n    return exists ? valueExists : !valueExists;\n  }\n  return (typeof truthy > \"u\" ? !0 : truthy) ? !!value : !value;\n}, includeConditionalArg = (argType, args, globals) => {\n  if (!argType.if)\n    return !0;\n  let { arg, global: global5 } = argType.if;\n  if (count([arg, global5]) !== 1)\n    throw new Error(`Invalid conditional value ${JSON.stringify({ arg, global: global5 })}`);\n  let value = arg ? args[arg] : globals[global5];\n  return testValue(argType.if, value);\n};\n\n// src/csf/csf-factories.ts\nimport { combineTags } from \"storybook/internal/csf\";\n\n// src/actions/preview.ts\nimport { definePreviewAddon } from \"storybook/internal/csf\";\n\n// src/actions/addArgs.ts\nvar addArgs_exports = {};\n__export(addArgs_exports, {\n  argsEnhancers: () => argsEnhancers\n});\n\n// src/actions/addArgsHelpers.ts\nvar isInInitialArgs = (name, initialArgs) => typeof initialArgs[name] > \"u\" && !(name in initialArgs), inferActionsFromArgTypesRegex = (context) => {\n  let {\n    initialArgs,\n    argTypes,\n    id,\n    parameters: { actions }\n  } = context;\n  if (!actions || actions.disable || !actions.argTypesRegex || !argTypes)\n    return {};\n  let argTypesRegex = new RegExp(actions.argTypesRegex);\n  return Object.entries(argTypes).filter(\n    ([name]) => !!argTypesRegex.test(name)\n  ).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(name, { implicit: !0, id })), acc), {});\n}, addActionsFromArgTypes = (context) => {\n  let {\n    initialArgs,\n    argTypes,\n    parameters: { actions }\n  } = context;\n  return actions?.disable || !argTypes ? {} : Object.entries(argTypes).filter(([name, argType]) => !!argType.action).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(typeof argType.action == \"string\" ? argType.action : name)), acc), {});\n};\n\n// src/actions/addArgs.ts\nvar argsEnhancers = [\n  addActionsFromArgTypes,\n  inferActionsFromArgTypesRegex\n];\n\n// src/actions/loaders.ts\nvar loaders_exports = {};\n__export(loaders_exports, {\n  loaders: () => loaders\n});\nimport { onMockCall } from \"storybook/test\";\nvar subscribed = !1, logActionsWhenMockCalled = (context) => {\n  let { parameters: parameters2 } = context;\n  parameters2?.actions?.disable || subscribed || (onMockCall((mock, args) => {\n    let name = mock.getMockName();\n    name !== \"spy\" && name !== \"vi.fn()\" && (!/^next\\/.*::/.test(name) || [\n      \"next/router::useRouter()\",\n      \"next/navigation::useRouter()\",\n      \"next/navigation::redirect\",\n      \"next/cache::\",\n      \"next/headers::cookies().set\",\n      \"next/headers::cookies().delete\",\n      \"next/headers::headers().set\",\n      \"next/headers::headers().delete\"\n    ].some((prefix) => name.startsWith(prefix))) && action(name)(args);\n  }), subscribed = !0);\n}, loaders = [logActionsWhenMockCalled];\n\n// src/actions/preview.ts\nvar preview_default = () => definePreviewAddon({\n  ...addArgs_exports,\n  ...loaders_exports\n});\n\n// src/backgrounds/preview.ts\nimport { definePreviewAddon as definePreviewAddon2 } from \"storybook/internal/csf\";\n\n// src/backgrounds/decorator.ts\nimport { useEffect } from \"storybook/preview-api\";\n\n// src/backgrounds/utils.ts\nvar { document: document2 } = globalThis, isReduceMotionEnabled = () => globalThis?.matchMedia ? !!globalThis.matchMedia(\"(prefers-reduced-motion: reduce)\")?.matches : !1, clearStyles = (selector) => {\n  (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle);\n}, clearStyle = (selector) => {\n  if (!document2)\n    return;\n  let element = document2.getElementById(selector);\n  element && element.parentElement && element.parentElement.removeChild(element);\n}, addGridStyle = (selector, css) => {\n  if (!document2)\n    return;\n  let existingStyle = document2.getElementById(selector);\n  if (existingStyle)\n    existingStyle.innerHTML !== css && (existingStyle.innerHTML = css);\n  else {\n    let style = document2.createElement(\"style\");\n    style.setAttribute(\"id\", selector), style.innerHTML = css, document2.head.appendChild(style);\n  }\n}, addBackgroundStyle = (selector, css, storyId) => {\n  if (!document2)\n    return;\n  let existingStyle = document2.getElementById(selector);\n  if (existingStyle)\n    existingStyle.innerHTML !== css && (existingStyle.innerHTML = css);\n  else {\n    let style = document2.createElement(\"style\");\n    style.setAttribute(\"id\", selector), style.innerHTML = css;\n    let gridStyleSelector = `addon-backgrounds-grid${storyId ? `-docs-${storyId}` : \"\"}`, existingGridStyle = document2.getElementById(gridStyleSelector);\n    existingGridStyle ? existingGridStyle.parentElement?.insertBefore(style, existingGridStyle) : document2.head.appendChild(style);\n  }\n};\n\n// src/backgrounds/decorator.ts\nvar defaultGrid = {\n  cellSize: 100,\n  cellAmount: 10,\n  opacity: 0.8\n}, BG_SELECTOR_BASE = \"addon-backgrounds\", GRID_SELECTOR_BASE = \"addon-backgrounds-grid\", transitionStyle = isReduceMotionEnabled() ? \"\" : \"transition: background-color 0.3s;\", withBackgroundAndGrid = (StoryFn, context) => {\n  let { globals = {}, parameters: parameters2 = {}, viewMode, id } = context, {\n    options = DEFAULT_BACKGROUNDS,\n    disable,\n    grid = defaultGrid\n  } = parameters2[PARAM_KEY2] || {}, data = globals[PARAM_KEY2] || {}, backgroundName = typeof data == \"string\" ? data : data?.value, item = backgroundName ? options[backgroundName] : void 0, value = typeof item == \"string\" ? item : item?.value || \"transparent\", showGrid = typeof data == \"string\" ? !1 : data.grid || !1, shownBackground = !!item && !disable, backgroundSelector = viewMode === \"docs\" ? `#anchor--${id} .docs-story` : \".sb-show-main\", gridSelector = viewMode === \"docs\" ? `#anchor--${id} .docs-story` : \".sb-show-main\", isLayoutPadded = parameters2.layout === void 0 || parameters2.layout === \"padded\", defaultOffset = viewMode === \"docs\" ? 20 : isLayoutPadded ? 16 : 0, { cellAmount, cellSize, opacity, offsetX = defaultOffset, offsetY = defaultOffset } = grid, backgroundSelectorId = viewMode === \"docs\" ? `${BG_SELECTOR_BASE}-docs-${id}` : `${BG_SELECTOR_BASE}-color`, backgroundTarget = viewMode === \"docs\" ? id : null;\n  useEffect(() => {\n    let backgroundStyles = `\n    ${backgroundSelector} {\n      background: ${value} !important;\n      ${transitionStyle}\n      }`;\n    if (!shownBackground) {\n      clearStyles(backgroundSelectorId);\n      return;\n    }\n    addBackgroundStyle(backgroundSelectorId, backgroundStyles, backgroundTarget);\n  }, [backgroundSelector, backgroundSelectorId, backgroundTarget, shownBackground, value]);\n  let gridSelectorId = viewMode === \"docs\" ? `${GRID_SELECTOR_BASE}-docs-${id}` : `${GRID_SELECTOR_BASE}`;\n  return useEffect(() => {\n    if (!showGrid) {\n      clearStyles(gridSelectorId);\n      return;\n    }\n    let gridSize = [\n      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,\n      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,\n      `${cellSize}px ${cellSize}px`,\n      `${cellSize}px ${cellSize}px`\n    ].join(\", \"), gridStyles = `\n        ${gridSelector} {\n          background-size: ${gridSize} !important;\n          background-position: ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px !important;\n          background-blend-mode: difference !important;\n          background-image: linear-gradient(rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),\n           linear-gradient(90deg, rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),\n           linear-gradient(rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px),\n           linear-gradient(90deg, rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px) !important;\n        }\n      `;\n    addGridStyle(gridSelectorId, gridStyles);\n  }, [cellAmount, cellSize, gridSelector, gridSelectorId, showGrid, offsetX, offsetY, opacity]), StoryFn();\n};\n\n// src/backgrounds/preview.ts\nvar decorators = globalThis.FEATURES?.backgrounds ? [withBackgroundAndGrid] : [], parameters = {\n  [PARAM_KEY2]: {\n    grid: {\n      cellSize: 20,\n      opacity: 0.5,\n      cellAmount: 5\n    },\n    disable: !1\n  }\n}, initialGlobals = {\n  [PARAM_KEY2]: { value: void 0, grid: !1 }\n}, preview_default2 = () => definePreviewAddon2({\n  decorators,\n  parameters,\n  initialGlobals\n});\n\n// src/component-testing/preview.ts\nimport { definePreviewAddon as definePreviewAddon3 } from \"storybook/internal/csf\";\nimport { instrument } from \"storybook/internal/instrumenter\";\nvar { step } = instrument(\n  {\n    // It seems like the label is unused, but the instrumenter has access to it\n    // The context will be bounded later in StoryRender, so that the user can write just:\n    // await step(\"label\", (context) => {\n    //   // labeled step\n    // });\n    step: async (label, play, context) => play(context)\n  },\n  { intercept: !0 }\n), preview_default3 = () => definePreviewAddon3({\n  parameters: {\n    throwPlayFunctionExceptions: !1\n  },\n  runStep: step\n});\n\n// src/core-server/utils/ghost-stories/test-annotations.ts\nimport { definePreviewAddon as definePreviewAddon4 } from \"storybook/internal/csf\";\nvar isEmptyRender = (element) => {\n  let style = getComputedStyle(element), rect = element.getBoundingClientRect();\n  return !(rect.width > 0 && rect.height > 0 && style.visibility !== \"hidden\" && Number(style.opacity) > 0 && style.display !== \"none\");\n}, afterEach = async ({ reporting, canvasElement, globals }) => {\n  try {\n    if (!globals.ghostStories)\n      return;\n    let emptyRender = isEmptyRender(canvasElement.firstElementChild ?? canvasElement);\n    emptyRender && reporting.addReport({\n      type: \"render-analysis\",\n      version: 1,\n      result: {\n        emptyRender\n      },\n      status: \"warning\"\n    });\n  } catch {\n  }\n}, test_annotations_default = () => definePreviewAddon4({ afterEach });\n\n// src/highlight/preview.ts\nimport { definePreviewAddon as definePreviewAddon5 } from \"storybook/internal/csf\";\nimport { addons } from \"storybook/preview-api\";\n\n// src/highlight/useHighlights.ts\nimport { STORY_RENDER_PHASE_CHANGED } from \"storybook/internal/core-events\";\n\n// src/highlight/icons.ts\nvar iconPaths = {\n  chevronLeft: [\n    \"M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z\"\n  ],\n  chevronRight: [\n    \"M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z\"\n  ],\n  info: [\n    \"M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z\",\n    \"M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z\"\n  ],\n  shareAlt: [\n    \"M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z\",\n    \"M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z\"\n  ]\n};\n\n// src/highlight/utils.ts\nvar svgElements = \"svg,path,rect,circle,line,polyline,polygon,ellipse,text\".split(\",\"), createElement = (type, props = {}, children) => {\n  let element = svgElements.includes(type) ? document.createElementNS(\"http://www.w3.org/2000/svg\", type) : document.createElement(type);\n  return Object.entries(props).forEach(([key, val]) => {\n    /[A-Z]/.test(key) ? (key === \"onClick\" && (element.addEventListener(\"click\", val), element.addEventListener(\"keydown\", (e) => {\n      (e.key === \"Enter\" || e.key === \" \") && (e.preventDefault(), val());\n    })), key === \"onMouseEnter\" && element.addEventListener(\"mouseenter\", val), key === \"onMouseLeave\" && element.addEventListener(\"mouseleave\", val)) : element.setAttribute(key, val);\n  }), children?.forEach((child) => {\n    if (!(child == null || child === !1))\n      try {\n        element.appendChild(child);\n      } catch {\n        element.appendChild(document.createTextNode(String(child)));\n      }\n  }), element;\n}, createIcon = (name) => iconPaths[name] && createElement(\n  \"svg\",\n  { width: \"14\", height: \"14\", viewBox: \"0 0 14 14\", xmlns: \"http://www.w3.org/2000/svg\" },\n  iconPaths[name].map(\n    (d) => createElement(\"path\", {\n      fill: \"currentColor\",\n      \"fill-rule\": \"evenodd\",\n      \"clip-rule\": \"evenodd\",\n      d\n    })\n  )\n), normalizeOptions = (options) => {\n  if (\"elements\" in options) {\n    let { elements, color, style } = options;\n    return {\n      id: void 0,\n      priority: 0,\n      selectors: elements,\n      styles: {\n        outline: `2px ${style} ${color}`,\n        outlineOffset: \"2px\",\n        boxShadow: \"0 0 0 6px rgba(255,255,255,0.6)\"\n      },\n      menu: void 0\n    };\n  }\n  let { menu, ...rest } = options;\n  return {\n    id: void 0,\n    priority: 0,\n    styles: {\n      outline: \"2px dashed #029cfd\"\n    },\n    ...rest,\n    menu: Array.isArray(menu) ? menu.every(Array.isArray) ? menu : [menu] : void 0\n  };\n}, isFunction = (obj) => obj instanceof Function, state = /* @__PURE__ */ new Map(), listeners = /* @__PURE__ */ new Map(), teardowns = /* @__PURE__ */ new Map(), useStore = (initialValue) => {\n  let key = Symbol();\n  return listeners.set(key, []), state.set(key, initialValue), { get: () => state.get(key), set: (update) => {\n    let current = state.get(key), next = isFunction(update) ? update(current) : update;\n    next !== current && (state.set(key, next), listeners.get(key)?.forEach((listener) => {\n      teardowns.get(listener)?.(), teardowns.set(listener, listener(next));\n    }));\n  }, subscribe: (listener) => (listeners.get(key)?.push(listener), () => {\n    let list = listeners.get(key);\n    list && listeners.set(\n      key,\n      list.filter((l) => l !== listener)\n    );\n  }), teardown: () => {\n    listeners.get(key)?.forEach((listener) => {\n      teardowns.get(listener)?.(), teardowns.delete(listener);\n    }), listeners.delete(key), state.delete(key);\n  } };\n}, mapElements = (highlights) => {\n  let root = document.getElementById(\"storybook-root\"), map = /* @__PURE__ */ new Map();\n  for (let highlight of highlights) {\n    let { priority = 0 } = highlight;\n    for (let selector of highlight.selectors) {\n      let elements = [\n        ...document.querySelectorAll(\n          // Elements matching the selector, excluding storybook elements and their descendants.\n          // Necessary to find portaled elements (e.g. children of `body`).\n          `:is(${selector}):not([id^=\"storybook-\"], [id^=\"storybook-\"] *, [class^=\"sb-\"], [class^=\"sb-\"] *)`\n        ),\n        // Elements matching the selector inside the storybook root, as these were excluded above.\n        ...root?.querySelectorAll(selector) || []\n      ];\n      for (let element of elements) {\n        let existing = map.get(element);\n        (!existing || existing.priority <= priority) && map.set(element, {\n          ...highlight,\n          priority,\n          selectors: Array.from(new Set((existing?.selectors || []).concat(selector)))\n        });\n      }\n    }\n  }\n  return map;\n}, mapBoxes = (elements) => Array.from(elements.entries()).map(([element, { selectors, styles, hoverStyles, focusStyles, menu }]) => {\n  let { top, left, width, height } = element.getBoundingClientRect(), { position } = getComputedStyle(element);\n  return {\n    element,\n    selectors,\n    styles,\n    hoverStyles,\n    focusStyles,\n    menu,\n    top: position === \"fixed\" ? top : top + window.scrollY,\n    left: position === \"fixed\" ? left : left + window.scrollX,\n    width,\n    height\n  };\n}).sort((a, b) => b.width * b.height - a.width * a.height), isOverMenu = (menuElement, coordinates) => {\n  let menu = menuElement.getBoundingClientRect(), { x, y } = coordinates;\n  return menu?.top && menu?.left && x >= menu.left && x <= menu.left + menu.width && y >= menu.top && y <= menu.top + menu.height;\n}, isTargeted = (box, boxElement, coordinates) => {\n  if (!boxElement || !coordinates)\n    return !1;\n  let { left, top, width, height } = box;\n  height < MIN_TOUCH_AREA_SIZE && (top = top - Math.round((MIN_TOUCH_AREA_SIZE - height) / 2), height = MIN_TOUCH_AREA_SIZE), width < MIN_TOUCH_AREA_SIZE && (left = left - Math.round((MIN_TOUCH_AREA_SIZE - width) / 2), width = MIN_TOUCH_AREA_SIZE), boxElement.style.position === \"fixed\" && (left += window.scrollX, top += window.scrollY);\n  let { x, y } = coordinates;\n  return x >= left && x <= left + width && y >= top && y <= top + height;\n}, keepInViewport = (element, targetCoordinates, options = {}) => {\n  let { x, y } = targetCoordinates, { margin = 5, topOffset = 0, centered = !1 } = options, { scrollX, scrollY, innerHeight: windowHeight, innerWidth: windowWidth } = window, top = Math.min(\n    element.style.position === \"fixed\" ? y - scrollY : y,\n    windowHeight - element.clientHeight - margin - topOffset + scrollY\n  ), leftOffset = centered ? element.clientWidth / 2 : 0, left = element.style.position === \"fixed\" ? Math.max(Math.min(x - scrollX, windowWidth - leftOffset - margin), leftOffset + margin) : Math.max(\n    Math.min(x, windowWidth - leftOffset - margin + scrollX),\n    leftOffset + margin + scrollX\n  );\n  Object.assign(element.style, {\n    ...left !== x && { left: `${left}px` },\n    ...top !== y && { top: `${top}px` }\n  });\n}, showPopover = (element) => {\n  window.HTMLElement.prototype.hasOwnProperty(\"showPopover\") && element.showPopover();\n}, hidePopover = (element) => {\n  window.HTMLElement.prototype.hasOwnProperty(\"showPopover\") && element.hidePopover();\n}, getEventDetails = (target) => ({\n  top: target.top,\n  left: target.left,\n  width: target.width,\n  height: target.height,\n  selectors: target.selectors,\n  element: {\n    attributes: Object.fromEntries(\n      Array.from(target.element.attributes).map((attr) => [attr.name, attr.value])\n    ),\n    localName: target.element.localName,\n    tagName: target.element.tagName,\n    outerHTML: target.element.outerHTML\n  }\n});\n\n// src/highlight/useHighlights.ts\nvar menuId = \"storybook-highlights-menu\", rootId = \"storybook-highlights-root\", storybookRootId = \"storybook-root\", useHighlights = (channel) => {\n  if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED)\n    return;\n  globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = !0;\n  let { document: document3 } = globalThis, highlights = useStore([]), elements = useStore(/* @__PURE__ */ new Map()), boxes = useStore([]), clickCoords = useStore(), hoverCoords = useStore(), targets = useStore([]), hovered = useStore([]), focused = useStore(), selected = useStore(), root = document3.getElementById(rootId);\n  highlights.subscribe(() => {\n    root || (root = createElement(\"div\", { id: rootId }), document3.body.appendChild(root));\n  }), highlights.subscribe((value) => {\n    let storybookRoot = document3.getElementById(storybookRootId);\n    if (!storybookRoot)\n      return;\n    elements.set(mapElements(value));\n    let observer = new MutationObserver(() => elements.set(mapElements(value)));\n    return observer.observe(storybookRoot, { subtree: !0, childList: !0 }), () => {\n      observer.disconnect();\n    };\n  }), elements.subscribe((value) => {\n    let updateBoxes = () => requestAnimationFrame(() => boxes.set(mapBoxes(value))), observer = new ResizeObserver(updateBoxes);\n    observer.observe(document3.body), Array.from(value.keys()).forEach((element) => observer.observe(element));\n    let scrollers = Array.from(document3.body.querySelectorAll(\"*\")).filter((el) => {\n      let { overflow, overflowX, overflowY } = window.getComputedStyle(el);\n      return [\"auto\", \"scroll\"].some((o) => [overflow, overflowX, overflowY].includes(o));\n    });\n    return scrollers.forEach((element) => element.addEventListener(\"scroll\", updateBoxes)), () => {\n      observer.disconnect(), scrollers.forEach((element) => element.removeEventListener(\"scroll\", updateBoxes));\n    };\n  }), elements.subscribe((value) => {\n    let sticky = Array.from(value.keys()).filter(({ style }) => style.position === \"sticky\"), updateBoxes = () => requestAnimationFrame(() => {\n      boxes.set(\n        (current) => current.map((box) => {\n          if (sticky.includes(box.element)) {\n            let { top, left } = box.element.getBoundingClientRect();\n            return { ...box, top: top + window.scrollY, left: left + window.scrollX };\n          }\n          return box;\n        })\n      );\n    });\n    return document3.addEventListener(\"scroll\", updateBoxes), () => document3.removeEventListener(\"scroll\", updateBoxes);\n  }), elements.subscribe((value) => {\n    targets.set((t) => t.filter(({ element }) => value.has(element)));\n  }), targets.subscribe((value) => {\n    value.length ? (selected.set((s) => value.some((t) => t.element === s?.element) ? s : void 0), focused.set((s) => value.some((t) => t.element === s?.element) ? s : void 0)) : (selected.set(void 0), focused.set(void 0), clickCoords.set(void 0));\n  });\n  let styleElementByHighlight = new Map(/* @__PURE__ */ new Map());\n  highlights.subscribe((value) => {\n    value.forEach(({ keyframes }) => {\n      if (keyframes) {\n        let style = styleElementByHighlight.get(keyframes);\n        style || (style = document3.createElement(\"style\"), style.setAttribute(\"data-highlight\", \"keyframes\"), styleElementByHighlight.set(keyframes, style), document3.head.appendChild(style)), style.innerHTML = keyframes;\n      }\n    }), styleElementByHighlight.forEach((style, keyframes) => {\n      value.some((v) => v.keyframes === keyframes) || (style.remove(), styleElementByHighlight.delete(keyframes));\n    });\n  });\n  let boxElementByTargetElement = new Map(/* @__PURE__ */ new Map());\n  boxes.subscribe((value) => {\n    value.forEach((box) => {\n      let boxElement = boxElementByTargetElement.get(box.element);\n      if (root && !boxElement) {\n        let props = {\n          popover: \"manual\",\n          \"data-highlight-dimensions\": `w${box.width.toFixed(0)}h${box.height.toFixed(0)}`,\n          \"data-highlight-coordinates\": `x${box.left.toFixed(0)}y${box.top.toFixed(0)}`\n        };\n        boxElement = root.appendChild(\n          createElement(\"div\", props, [createElement(\"div\")])\n        ), boxElementByTargetElement.set(box.element, boxElement);\n      }\n    }), boxElementByTargetElement.forEach((box, element) => {\n      value.some(({ element: e }) => e === element) || (box.remove(), boxElementByTargetElement.delete(element));\n    });\n  }), boxes.subscribe((value) => {\n    let targetable = value.filter((box) => box.menu);\n    if (!targetable.length)\n      return;\n    let onClick = (event) => {\n      requestAnimationFrame(() => {\n        let menu = document3.getElementById(menuId), coords = { x: event.pageX, y: event.pageY };\n        if (menu && !isOverMenu(menu, coords)) {\n          let results = targetable.filter((box) => {\n            let boxElement = boxElementByTargetElement.get(box.element);\n            return isTargeted(box, boxElement, coords);\n          });\n          clickCoords.set(results.length ? coords : void 0), targets.set(results);\n        }\n      });\n    };\n    return document3.addEventListener(\"click\", onClick), () => document3.removeEventListener(\"click\", onClick);\n  });\n  let updateHovered = () => {\n    let menu = document3.getElementById(menuId), coords = hoverCoords.get();\n    !coords || menu && isOverMenu(menu, coords) || hovered.set((current) => {\n      let update = boxes.get().filter((box) => {\n        let boxElement = boxElementByTargetElement.get(box.element);\n        return isTargeted(box, boxElement, coords);\n      }), existing = current.filter((box) => update.includes(box)), additions = update.filter((box) => !current.includes(box)), hasRemovals = current.length - existing.length;\n      return additions.length || hasRemovals ? [...existing, ...additions] : current;\n    });\n  };\n  hoverCoords.subscribe(updateHovered), boxes.subscribe(updateHovered);\n  let updateBoxStyles = () => {\n    let selectedElement = selected.get(), targetElements = selectedElement ? [selectedElement] : targets.get(), focusedElement = targetElements.length === 1 ? targetElements[0] : focused.get(), isMenuOpen = clickCoords.get() !== void 0;\n    boxes.get().forEach((box) => {\n      let boxElement = boxElementByTargetElement.get(box.element);\n      if (boxElement) {\n        let isFocused = focusedElement === box, isHovered = isMenuOpen ? focusedElement ? isFocused : targetElements.includes(box) : hovered.get()?.includes(box);\n        Object.assign(boxElement.style, {\n          animation: \"none\",\n          background: \"transparent\",\n          border: \"none\",\n          boxSizing: \"border-box\",\n          outline: \"none\",\n          outlineOffset: \"0px\",\n          ...box.styles,\n          ...isHovered ? box.hoverStyles : {},\n          ...isFocused ? box.focusStyles : {},\n          position: getComputedStyle(box.element).position === \"fixed\" ? \"fixed\" : \"absolute\",\n          zIndex: MAX_Z_INDEX - 10,\n          top: `${box.top}px`,\n          left: `${box.left}px`,\n          width: `${box.width}px`,\n          height: `${box.height}px`,\n          margin: 0,\n          padding: 0,\n          cursor: box.menu && isHovered ? \"pointer\" : \"default\",\n          pointerEvents: box.menu ? \"auto\" : \"none\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          overflow: \"visible\"\n        }), Object.assign(boxElement.children[0].style, {\n          width: \"100%\",\n          height: \"100%\",\n          minHeight: `${MIN_TOUCH_AREA_SIZE}px`,\n          minWidth: `${MIN_TOUCH_AREA_SIZE}px`,\n          boxSizing: \"content-box\",\n          padding: boxElement.style.outlineWidth || \"0px\"\n        }), showPopover(boxElement);\n      }\n    });\n  };\n  boxes.subscribe(updateBoxStyles), targets.subscribe(updateBoxStyles), hovered.subscribe(updateBoxStyles), focused.subscribe(updateBoxStyles), selected.subscribe(updateBoxStyles);\n  let renderMenu = () => {\n    if (!root)\n      return;\n    let menu = document3.getElementById(menuId);\n    if (menu)\n      menu.innerHTML = \"\";\n    else {\n      let props = { id: menuId, popover: \"manual\" };\n      menu = root.appendChild(createElement(\"div\", props)), root.appendChild(\n        createElement(\"style\", {}, [\n          `\n            #${menuId} {\n              position: absolute;\n              z-index: ${MAX_Z_INDEX};\n              width: 300px;\n              padding: 0px;\n              margin: 15px 0 0 0;\n              transform: translateX(-50%);\n              font-family: \"Nunito Sans\", -apple-system, \".SFNSText-Regular\", \"San Francisco\", BlinkMacSystemFont, \"Segoe UI\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n              font-size: 12px;\n              background: white;\n              border: none;\n              border-radius: 6px;\n              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);\n              color: #2E3438;\n            }\n            #${menuId} ul {\n              list-style: none;\n              margin: 0;\n              padding: 0;\n            }\n            #${menuId} > ul {\n              max-height: 300px;\n              overflow-y: auto;\n              padding: 4px 0;\n            }\n            #${menuId} li {\n              padding: 0 4px;\n              margin: 0;\n            }\n            #${menuId} li > :not(ul) {\n              display: flex;\n              padding: 8px;\n              margin: 0;\n              align-items: center;\n              gap: 8px;\n              border-radius: 4px;\n            }\n            #${menuId} button {\n              width: 100%;\n              border: 0;\n              background: transparent;\n              color: inherit;\n              text-align: left;\n              font-family: inherit;\n              font-size: inherit;\n            }\n            #${menuId} button:focus-visible {\n              outline-color: #029CFD;\n            }\n            #${menuId} button:hover {\n              background: rgba(2, 156, 253, 0.07);\n              color: #029CFD;\n              cursor: pointer;\n            }\n            #${menuId} li code {\n              white-space: nowrap;\n              overflow: hidden;\n              text-overflow: ellipsis;\n              line-height: 16px;\n              font-size: 11px;\n            }\n            #${menuId} li svg {\n              flex-shrink: 0;\n              margin: 1px;\n              color: #73828C;\n            }\n            #${menuId} li > button:hover svg, #${menuId} li > button:focus-visible svg {\n              color: #029CFD;\n            }\n            #${menuId} .element-list li svg {\n              display: none;\n            }\n            #${menuId} li.selectable svg, #${menuId} li.selected svg {\n              display: block;\n            }\n            #${menuId} .menu-list {\n              border-top: 1px solid rgba(38, 85, 115, 0.15);\n            }\n            #${menuId} .menu-list > li:not(:last-child) {\n              padding-bottom: 4px;\n              margin-bottom: 4px;\n              border-bottom: 1px solid rgba(38, 85, 115, 0.15);\n            }\n            #${menuId} .menu-items, #${menuId} .menu-items li {\n              padding: 0;\n            }\n            #${menuId} .menu-item {\n              display: flex;\n            }\n            #${menuId} .menu-item-content {\n              display: flex;\n              flex-direction: column;\n              flex-grow: 1;\n            }\n          `\n        ])\n      );\n    }\n    let selectedElement = selected.get(), elementList = selectedElement ? [selectedElement] : targets.get();\n    if (elementList.length && (menu.style.position = getComputedStyle(elementList[0].element).position === \"fixed\" ? \"fixed\" : \"absolute\", menu.appendChild(\n      createElement(\n        \"ul\",\n        { class: \"element-list\" },\n        elementList.map((target) => {\n          let selectable = elementList.length > 1 && !!target.menu?.some(\n            (group) => group.some(\n              (item) => !item.selectors || item.selectors.some((s) => target.selectors.includes(s))\n            )\n          ), props = selectable ? {\n            class: \"selectable\",\n            onClick: () => selected.set(target),\n            onMouseEnter: () => focused.set(target),\n            onMouseLeave: () => focused.set(void 0)\n          } : selectedElement ? { class: \"selected\", onClick: () => selected.set(void 0) } : {}, asButton = selectable || selectedElement;\n          return createElement(\"li\", props, [\n            createElement(asButton ? \"button\" : \"div\", asButton ? { type: \"button\" } : {}, [\n              selectedElement ? createIcon(\"chevronLeft\") : null,\n              createElement(\"code\", {}, [target.element.outerHTML]),\n              selectable ? createIcon(\"chevronRight\") : null\n            ])\n          ]);\n        })\n      )\n    )), selected.get() || targets.get().length === 1) {\n      let target = selected.get() || targets.get()[0], menuGroups = target.menu?.filter(\n        (group) => group.some(\n          (item) => !item.selectors || item.selectors.some((s) => target.selectors.includes(s))\n        )\n      );\n      menuGroups?.length && menu.appendChild(\n        createElement(\n          \"ul\",\n          { class: \"menu-list\" },\n          menuGroups.map(\n            (menuItems) => createElement(\"li\", {}, [\n              createElement(\n                \"ul\",\n                { class: \"menu-items\" },\n                menuItems.map(\n                  ({ id, title, description, iconLeft, iconRight, clickEvent: event }) => {\n                    let onClick = event && (() => channel.emit(event, id, getEventDetails(target)));\n                    return createElement(\"li\", {}, [\n                      createElement(\n                        onClick ? \"button\" : \"div\",\n                        onClick ? { class: \"menu-item\", type: \"button\", onClick } : { class: \"menu-item\" },\n                        [\n                          iconLeft ? createIcon(iconLeft) : null,\n                          createElement(\"div\", { class: \"menu-item-content\" }, [\n                            createElement(description ? \"strong\" : \"span\", {}, [title]),\n                            description && createElement(\"span\", {}, [description])\n                          ]),\n                          iconRight ? createIcon(iconRight) : null\n                        ]\n                      )\n                    ]);\n                  }\n                )\n              )\n            ])\n          )\n        )\n      );\n    }\n    let coords = clickCoords.get();\n    coords ? (Object.assign(menu.style, {\n      display: \"block\",\n      left: `${menu.style.position === \"fixed\" ? coords.x - window.scrollX : coords.x}px`,\n      top: `${menu.style.position === \"fixed\" ? coords.y - window.scrollY : coords.y}px`\n    }), showPopover(menu), requestAnimationFrame(() => keepInViewport(menu, coords, { topOffset: 15, centered: !0 }))) : (hidePopover(menu), Object.assign(menu.style, { display: \"none\" }));\n  };\n  targets.subscribe(renderMenu), selected.subscribe(renderMenu);\n  let addHighlight = (highlight) => {\n    let info = normalizeOptions(highlight);\n    highlights.set((value) => {\n      let others = info.id ? value.filter((h) => h.id !== info.id) : value;\n      return info.selectors?.length ? [...others, info] : others;\n    });\n  }, removeHighlight = (id) => {\n    id && highlights.set((value) => value.filter((h) => h.id !== id));\n  }, resetState = () => {\n    highlights.set([]), elements.set(/* @__PURE__ */ new Map()), boxes.set([]), clickCoords.set(void 0), hoverCoords.set(void 0), targets.set([]), hovered.set([]), focused.set(void 0), selected.set(void 0);\n  }, removeTimeout, scrollIntoView = (target, options) => {\n    let id = \"scrollIntoView-highlight\";\n    clearTimeout(removeTimeout), removeHighlight(id);\n    let element = document3.querySelector(target);\n    if (!element) {\n      console.warn(`Cannot scroll into view: ${target} not found`);\n      return;\n    }\n    element.scrollIntoView({ behavior: \"smooth\", block: \"center\", ...options });\n    let keyframeName = `kf-${Math.random().toString(36).substring(2, 15)}`;\n    highlights.set((value) => [\n      ...value,\n      {\n        id,\n        priority: 1e3,\n        selectors: [target],\n        styles: {\n          outline: \"2px solid #1EA7FD\",\n          outlineOffset: \"-1px\",\n          animation: `${keyframeName} 3s linear forwards`\n        },\n        keyframes: `@keyframes ${keyframeName} {\n          0% { outline: 2px solid #1EA7FD; }\n          20% { outline: 2px solid #1EA7FD00; }\n          40% { outline: 2px solid #1EA7FD; }\n          60% { outline: 2px solid #1EA7FD00; }\n          80% { outline: 2px solid #1EA7FD; }\n          100% { outline: 2px solid #1EA7FD00; }\n        }`\n      }\n    ]), removeTimeout = setTimeout(() => removeHighlight(id), 3500);\n  }, onMouseMove = (event) => {\n    requestAnimationFrame(() => hoverCoords.set({ x: event.pageX, y: event.pageY }));\n  };\n  document3.body.addEventListener(\"mousemove\", onMouseMove), channel.on(HIGHLIGHT, addHighlight), channel.on(REMOVE_HIGHLIGHT, removeHighlight), channel.on(RESET_HIGHLIGHT, resetState), channel.on(SCROLL_INTO_VIEW, scrollIntoView), channel.on(STORY_RENDER_PHASE_CHANGED, ({ newPhase }) => {\n    newPhase === \"loading\" && resetState();\n  });\n};\n\n// src/highlight/preview.ts\nglobalThis?.FEATURES?.highlight && addons?.ready && addons.ready().then(useHighlights);\nvar preview_default4 = () => definePreviewAddon5({});\n\n// src/measure/preview.ts\nimport { definePreviewAddon as definePreviewAddon6 } from \"storybook/internal/csf\";\n\n// src/measure/withMeasure.ts\nimport { useEffect as useEffect2 } from \"storybook/preview-api\";\n\n// src/measure/box-model/canvas.ts\nimport { global } from \"@storybook/global\";\nfunction getDocumentWidthAndHeight() {\n  let container = global.document.documentElement, height = Math.max(container.scrollHeight, container.offsetHeight);\n  return { width: Math.max(container.scrollWidth, container.offsetWidth), height };\n}\nfunction createCanvas() {\n  let canvas = global.document.createElement(\"canvas\");\n  canvas.id = \"storybook-addon-measure\";\n  let context = canvas.getContext(\"2d\");\n  invariant(context != null);\n  let { width, height } = getDocumentWidthAndHeight();\n  return setCanvasWidthAndHeight(canvas, context, { width, height }), canvas.style.position = \"absolute\", canvas.style.left = \"0\", canvas.style.top = \"0\", canvas.style.zIndex = \"2147483647\", canvas.style.pointerEvents = \"none\", global.document.body.appendChild(canvas), { canvas, context, width, height };\n}\nfunction setCanvasWidthAndHeight(canvas, context, { width, height }) {\n  canvas.style.width = `${width}px`, canvas.style.height = `${height}px`;\n  let scale = global.window.devicePixelRatio;\n  canvas.width = Math.floor(width * scale), canvas.height = Math.floor(height * scale), context.scale(scale, scale);\n}\nvar state2 = {};\nfunction init() {\n  state2.canvas || (state2 = createCanvas());\n}\nfunction clear() {\n  state2.context && state2.context.clearRect(0, 0, state2.width ?? 0, state2.height ?? 0);\n}\nfunction draw(callback) {\n  clear(), callback(state2.context);\n}\nfunction rescale() {\n  invariant(state2.canvas, \"Canvas should exist in the state.\"), invariant(state2.context, \"Context should exist in the state.\"), setCanvasWidthAndHeight(state2.canvas, state2.context, { width: 0, height: 0 });\n  let { width, height } = getDocumentWidthAndHeight();\n  setCanvasWidthAndHeight(state2.canvas, state2.context, { width, height }), state2.width = width, state2.height = height;\n}\nfunction destroy() {\n  state2.canvas && (clear(), state2.canvas.parentNode?.removeChild(state2.canvas), state2 = {});\n}\n\n// src/measure/box-model/visualizer.ts\nimport { global as global2 } from \"@storybook/global\";\n\n// src/measure/box-model/labels.ts\nvar colors = {\n  margin: \"#f6b26b\",\n  border: \"#ffe599\",\n  padding: \"#93c47d\",\n  content: \"#6fa8dc\",\n  text: \"#232020\"\n}, labelPadding = 6;\nfunction roundedRect(context, { x, y, w, h, r }) {\n  x = x - w / 2, y = y - h / 2, w < 2 * r && (r = w / 2), h < 2 * r && (r = h / 2), context.beginPath(), context.moveTo(x + r, y), context.arcTo(x + w, y, x + w, y + h, r), context.arcTo(x + w, y + h, x, y + h, r), context.arcTo(x, y + h, x, y, r), context.arcTo(x, y, x + w, y, r), context.closePath();\n}\nfunction positionCoordinate(position, { padding, border, width, height, top, left }) {\n  let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom, x = left + border.left + padding.left, y = top + border.top + padding.top;\n  return position === \"top\" ? x += contentWidth / 2 : position === \"right\" ? (x += contentWidth, y += contentHeight / 2) : position === \"bottom\" ? (x += contentWidth / 2, y += contentHeight) : position === \"left\" ? y += contentHeight / 2 : position === \"center\" && (x += contentWidth / 2, y += contentHeight / 2), { x, y };\n}\nfunction offset(type, position, { margin, border, padding }, labelPaddingSize, external) {\n  let shift = (dir) => 0, offsetX = 0, offsetY = 0, locationMultiplier = external ? 1 : 0.5, labelPaddingShift = external ? labelPaddingSize * 2 : 0;\n  return type === \"padding\" ? shift = (dir) => padding[dir] * locationMultiplier + labelPaddingShift : type === \"border\" ? shift = (dir) => padding[dir] + border[dir] * locationMultiplier + labelPaddingShift : type === \"margin\" && (shift = (dir) => padding[dir] + border[dir] + margin[dir] * locationMultiplier + labelPaddingShift), position === \"top\" ? offsetY = -shift(\"top\") : position === \"right\" ? offsetX = shift(\"right\") : position === \"bottom\" ? offsetY = shift(\"bottom\") : position === \"left\" && (offsetX = -shift(\"left\")), { offsetX, offsetY };\n}\nfunction collide(a, b) {\n  return Math.abs(a.x - b.x) < Math.abs(a.w + b.w) / 2 && Math.abs(a.y - b.y) < Math.abs(a.h + b.h) / 2;\n}\nfunction overlapAdjustment(position, currentRect, prevRect) {\n  return position === \"top\" ? currentRect.y = prevRect.y - prevRect.h - labelPadding : position === \"right\" ? currentRect.x = prevRect.x + prevRect.w / 2 + labelPadding + currentRect.w / 2 : position === \"bottom\" ? currentRect.y = prevRect.y + prevRect.h + labelPadding : position === \"left\" && (currentRect.x = prevRect.x - prevRect.w / 2 - labelPadding - currentRect.w / 2), { x: currentRect.x, y: currentRect.y };\n}\nfunction textWithRect(context, type, { x, y, w, h }, text) {\n  return roundedRect(context, { x, y, w, h, r: 3 }), context.fillStyle = `${colors[type]}dd`, context.fill(), context.strokeStyle = colors[type], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x, y), roundedRect(context, { x, y, w, h, r: 3 }), context.fillStyle = `${colors[type]}dd`, context.fill(), context.strokeStyle = colors[type], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x, y), { x, y, w, h };\n}\nfunction configureText(context, text) {\n  context.font = \"600 12px monospace\", context.textBaseline = \"middle\", context.textAlign = \"center\";\n  let metrics = context.measureText(text), actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent, w = metrics.width + labelPadding * 2, h = actualHeight + labelPadding * 2;\n  return { w, h };\n}\nfunction drawLabel(context, measurements, { type, position = \"center\", text }, prevRect, external = !1) {\n  let { x, y } = positionCoordinate(position, measurements), { offsetX, offsetY } = offset(type, position, measurements, labelPadding + 1, external);\n  x += offsetX, y += offsetY;\n  let { w, h } = configureText(context, text);\n  if (prevRect && collide({ x, y, w, h }, prevRect)) {\n    let adjusted = overlapAdjustment(position, { x, y, w, h }, prevRect);\n    x = adjusted.x, y = adjusted.y;\n  }\n  return textWithRect(context, type, { x, y, w, h }, text);\n}\nfunction floatingOffset(alignment, { w, h }) {\n  let deltaW = w * 0.5 + labelPadding, deltaH = h * 0.5 + labelPadding;\n  return {\n    offsetX: (alignment.x === \"left\" ? -1 : 1) * deltaW,\n    offsetY: (alignment.y === \"top\" ? -1 : 1) * deltaH\n  };\n}\nfunction drawFloatingLabel(context, measurements, { type, text }) {\n  let { floatingAlignment: floatingAlignment2, extremities } = measurements, x = extremities[floatingAlignment2.x], y = extremities[floatingAlignment2.y], { w, h } = configureText(context, text), { offsetX, offsetY } = floatingOffset(floatingAlignment2, {\n    w,\n    h\n  });\n  return x += offsetX, y += offsetY, textWithRect(context, type, { x, y, w, h }, text);\n}\nfunction drawStack(context, measurements, stack, external) {\n  let rects = [];\n  stack.forEach((l, idx) => {\n    let rect = external && l.position === \"center\" ? drawFloatingLabel(context, measurements, l) : drawLabel(context, measurements, l, rects[idx - 1], external);\n    rects[idx] = rect;\n  });\n}\nfunction labelStacks(context, measurements, labels, externalLabels) {\n  let stacks = labels.reduce((acc, l) => (Object.prototype.hasOwnProperty.call(acc, l.position) || (acc[l.position] = []), acc[l.position]?.push(l), acc), {});\n  stacks.top && drawStack(context, measurements, stacks.top, externalLabels), stacks.right && drawStack(context, measurements, stacks.right, externalLabels), stacks.bottom && drawStack(context, measurements, stacks.bottom, externalLabels), stacks.left && drawStack(context, measurements, stacks.left, externalLabels), stacks.center && drawStack(context, measurements, stacks.center, externalLabels);\n}\n\n// src/measure/box-model/visualizer.ts\nvar colors2 = {\n  margin: \"#f6b26ba8\",\n  border: \"#ffe599a8\",\n  padding: \"#93c47d8c\",\n  content: \"#6fa8dca8\"\n}, SMALL_NODE_SIZE = 30;\nfunction pxToNumber(px) {\n  return parseInt(px.replace(\"px\", \"\"), 10);\n}\nfunction round(value) {\n  return Number.isInteger(value) ? value : value.toFixed(2);\n}\nfunction filterZeroValues(labels) {\n  return labels.filter((l) => l.text !== 0 && l.text !== \"0\");\n}\nfunction floatingAlignment(extremities) {\n  let windowExtremities = {\n    top: global2.window.scrollY,\n    bottom: global2.window.scrollY + global2.window.innerHeight,\n    left: global2.window.scrollX,\n    right: global2.window.scrollX + global2.window.innerWidth\n  }, distances = {\n    top: Math.abs(windowExtremities.top - extremities.top),\n    bottom: Math.abs(windowExtremities.bottom - extremities.bottom),\n    left: Math.abs(windowExtremities.left - extremities.left),\n    right: Math.abs(windowExtremities.right - extremities.right)\n  };\n  return {\n    x: distances.left > distances.right ? \"left\" : \"right\",\n    y: distances.top > distances.bottom ? \"top\" : \"bottom\"\n  };\n}\nfunction measureElement(element) {\n  let style = global2.getComputedStyle(element), { top, left, right, bottom, width, height } = element.getBoundingClientRect(), {\n    marginTop,\n    marginBottom,\n    marginLeft,\n    marginRight,\n    paddingTop,\n    paddingBottom,\n    paddingLeft,\n    paddingRight,\n    borderBottomWidth,\n    borderTopWidth,\n    borderLeftWidth,\n    borderRightWidth\n  } = style;\n  top = top + global2.window.scrollY, left = left + global2.window.scrollX, bottom = bottom + global2.window.scrollY, right = right + global2.window.scrollX;\n  let margin = {\n    top: pxToNumber(marginTop),\n    bottom: pxToNumber(marginBottom),\n    left: pxToNumber(marginLeft),\n    right: pxToNumber(marginRight)\n  }, padding = {\n    top: pxToNumber(paddingTop),\n    bottom: pxToNumber(paddingBottom),\n    left: pxToNumber(paddingLeft),\n    right: pxToNumber(paddingRight)\n  }, border = {\n    top: pxToNumber(borderTopWidth),\n    bottom: pxToNumber(borderBottomWidth),\n    left: pxToNumber(borderLeftWidth),\n    right: pxToNumber(borderRightWidth)\n  }, extremities = {\n    top: top - margin.top,\n    bottom: bottom + margin.bottom,\n    left: left - margin.left,\n    right: right + margin.right\n  };\n  return {\n    margin,\n    padding,\n    border,\n    top,\n    left,\n    bottom,\n    right,\n    width,\n    height,\n    extremities,\n    floatingAlignment: floatingAlignment(extremities)\n  };\n}\nfunction drawMargin(context, { margin, width, height, top, left, bottom, right }) {\n  let marginHeight = height + margin.bottom + margin.top;\n  context.fillStyle = colors2.margin, context.fillRect(left, top - margin.top, width, margin.top), context.fillRect(right, top - margin.top, margin.right, marginHeight), context.fillRect(left, bottom, width, margin.bottom), context.fillRect(left - margin.left, top - margin.top, margin.left, marginHeight);\n  let marginLabels = [\n    {\n      type: \"margin\",\n      text: round(margin.top),\n      position: \"top\"\n    },\n    {\n      type: \"margin\",\n      text: round(margin.right),\n      position: \"right\"\n    },\n    {\n      type: \"margin\",\n      text: round(margin.bottom),\n      position: \"bottom\"\n    },\n    {\n      type: \"margin\",\n      text: round(margin.left),\n      position: \"left\"\n    }\n  ];\n  return filterZeroValues(marginLabels);\n}\nfunction drawPadding(context, { padding, border, width, height, top, left, bottom, right }) {\n  let paddingWidth = width - border.left - border.right, paddingHeight = height - padding.top - padding.bottom - border.top - border.bottom;\n  context.fillStyle = colors2.padding, context.fillRect(left + border.left, top + border.top, paddingWidth, padding.top), context.fillRect(\n    right - padding.right - border.right,\n    top + padding.top + border.top,\n    padding.right,\n    paddingHeight\n  ), context.fillRect(\n    left + border.left,\n    bottom - padding.bottom - border.bottom,\n    paddingWidth,\n    padding.bottom\n  ), context.fillRect(left + border.left, top + padding.top + border.top, padding.left, paddingHeight);\n  let paddingLabels = [\n    {\n      type: \"padding\",\n      text: padding.top,\n      position: \"top\"\n    },\n    {\n      type: \"padding\",\n      text: padding.right,\n      position: \"right\"\n    },\n    {\n      type: \"padding\",\n      text: padding.bottom,\n      position: \"bottom\"\n    },\n    {\n      type: \"padding\",\n      text: padding.left,\n      position: \"left\"\n    }\n  ];\n  return filterZeroValues(paddingLabels);\n}\nfunction drawBorder(context, { border, width, height, top, left, bottom, right }) {\n  let borderHeight = height - border.top - border.bottom;\n  context.fillStyle = colors2.border, context.fillRect(left, top, width, border.top), context.fillRect(left, bottom - border.bottom, width, border.bottom), context.fillRect(left, top + border.top, border.left, borderHeight), context.fillRect(right - border.right, top + border.top, border.right, borderHeight);\n  let borderLabels = [\n    {\n      type: \"border\",\n      text: border.top,\n      position: \"top\"\n    },\n    {\n      type: \"border\",\n      text: border.right,\n      position: \"right\"\n    },\n    {\n      type: \"border\",\n      text: border.bottom,\n      position: \"bottom\"\n    },\n    {\n      type: \"border\",\n      text: border.left,\n      position: \"left\"\n    }\n  ];\n  return filterZeroValues(borderLabels);\n}\nfunction drawContent(context, { padding, border, width, height, top, left }) {\n  let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;\n  return context.fillStyle = colors2.content, context.fillRect(\n    left + border.left + padding.left,\n    top + border.top + padding.top,\n    contentWidth,\n    contentHeight\n  ), [\n    {\n      type: \"content\",\n      position: \"center\",\n      text: `${round(contentWidth)} x ${round(contentHeight)}`\n    }\n  ];\n}\nfunction drawBoxModel(element) {\n  return (context) => {\n    if (element && context) {\n      let measurements = measureElement(element), marginLabels = drawMargin(context, measurements), paddingLabels = drawPadding(context, measurements), borderLabels = drawBorder(context, measurements), contentLabels = drawContent(context, measurements), externalLabels = measurements.width <= SMALL_NODE_SIZE * 3 || measurements.height <= SMALL_NODE_SIZE;\n      labelStacks(\n        context,\n        measurements,\n        [...contentLabels, ...paddingLabels, ...borderLabels, ...marginLabels],\n        externalLabels\n      );\n    }\n  };\n}\nfunction drawSelectedElement(element) {\n  draw(drawBoxModel(element));\n}\n\n// src/measure/util.ts\nimport { global as global3 } from \"@storybook/global\";\nvar deepElementFromPoint = (x, y) => {\n  let element = global3.document.elementFromPoint(x, y), crawlShadows = (node) => {\n    if (node && node.shadowRoot) {\n      let nestedElement = node.shadowRoot.elementFromPoint(x, y);\n      return node.isEqualNode(nestedElement) ? node : nestedElement.shadowRoot ? crawlShadows(nestedElement) : nestedElement;\n    }\n    return node;\n  };\n  return crawlShadows(element) || element;\n};\n\n// src/measure/withMeasure.ts\nvar nodeAtPointerRef, pointer = { x: 0, y: 0 };\nfunction findAndDrawElement(x, y) {\n  nodeAtPointerRef = deepElementFromPoint(x, y), drawSelectedElement(nodeAtPointerRef);\n}\nvar withMeasure = (StoryFn, context) => {\n  let { measureEnabled } = context.globals || {};\n  return useEffect2(() => {\n    if (typeof globalThis.document > \"u\")\n      return;\n    let onPointerMove = (event) => {\n      window.requestAnimationFrame(() => {\n        event.stopPropagation(), pointer.x = event.clientX, pointer.y = event.clientY;\n      });\n    };\n    return globalThis.document.addEventListener(\"pointermove\", onPointerMove), () => {\n      globalThis.document.removeEventListener(\"pointermove\", onPointerMove);\n    };\n  }, []), useEffect2(() => {\n    let onPointerOver = (event) => {\n      window.requestAnimationFrame(() => {\n        event.stopPropagation(), findAndDrawElement(event.clientX, event.clientY);\n      });\n    }, onResize = () => {\n      window.requestAnimationFrame(() => {\n        rescale();\n      });\n    };\n    return context.viewMode === \"story\" && measureEnabled && (globalThis.document.addEventListener(\"pointerover\", onPointerOver), init(), globalThis.window.addEventListener(\"resize\", onResize), findAndDrawElement(pointer.x, pointer.y)), () => {\n      globalThis.window.removeEventListener(\"resize\", onResize), destroy();\n    };\n  }, [measureEnabled, context.viewMode]), StoryFn();\n};\n\n// src/measure/preview.ts\nvar decorators2 = globalThis.FEATURES?.measure ? [withMeasure] : [], initialGlobals2 = {\n  [PARAM_KEY3]: !1\n}, preview_default5 = () => definePreviewAddon6({\n  decorators: decorators2,\n  initialGlobals: initialGlobals2\n});\n\n// src/outline/preview.ts\nimport { definePreviewAddon as definePreviewAddon7 } from \"storybook/internal/csf\";\n\n// src/outline/withOutline.ts\nimport { useEffect as useEffect3, useMemo } from \"storybook/preview-api\";\n\n// src/outline/helpers.ts\nimport { global as global4 } from \"@storybook/global\";\nvar clearStyles2 = (selector) => {\n  (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle2);\n}, clearStyle2 = (input) => {\n  let selector = typeof input == \"string\" ? input : input.join(\"\"), element = global4.document.getElementById(selector);\n  element && element.parentElement && element.parentElement.removeChild(element);\n}, addOutlineStyles = (selector, css) => {\n  let existingStyle = global4.document.getElementById(selector);\n  if (existingStyle)\n    existingStyle.innerHTML !== css && (existingStyle.innerHTML = css);\n  else {\n    let style = global4.document.createElement(\"style\");\n    style.setAttribute(\"id\", selector), style.innerHTML = css, global4.document.head.appendChild(style);\n  }\n};\n\n// src/outline/outlineCSS.ts\nfunction outlineCSS(selector) {\n  return dedent`\n    ${selector} body {\n      outline: 1px solid #2980b9 !important;\n    }\n\n    ${selector} article {\n      outline: 1px solid #3498db !important;\n    }\n\n    ${selector} nav {\n      outline: 1px solid #0088c3 !important;\n    }\n\n    ${selector} aside {\n      outline: 1px solid #33a0ce !important;\n    }\n\n    ${selector} section {\n      outline: 1px solid #66b8da !important;\n    }\n\n    ${selector} header {\n      outline: 1px solid #99cfe7 !important;\n    }\n\n    ${selector} footer {\n      outline: 1px solid #cce7f3 !important;\n    }\n\n    ${selector} h1 {\n      outline: 1px solid #162544 !important;\n    }\n\n    ${selector} h2 {\n      outline: 1px solid #314e6e !important;\n    }\n\n    ${selector} h3 {\n      outline: 1px solid #3e5e85 !important;\n    }\n\n    ${selector} h4 {\n      outline: 1px solid #449baf !important;\n    }\n\n    ${selector} h5 {\n      outline: 1px solid #c7d1cb !important;\n    }\n\n    ${selector} h6 {\n      outline: 1px solid #4371d0 !important;\n    }\n\n    ${selector} main {\n      outline: 1px solid #2f4f90 !important;\n    }\n\n    ${selector} address {\n      outline: 1px solid #1a2c51 !important;\n    }\n\n    ${selector} div {\n      outline: 1px solid #036cdb !important;\n    }\n\n    ${selector} p {\n      outline: 1px solid #ac050b !important;\n    }\n\n    ${selector} hr {\n      outline: 1px solid #ff063f !important;\n    }\n\n    ${selector} pre {\n      outline: 1px solid #850440 !important;\n    }\n\n    ${selector} blockquote {\n      outline: 1px solid #f1b8e7 !important;\n    }\n\n    ${selector} ol {\n      outline: 1px solid #ff050c !important;\n    }\n\n    ${selector} ul {\n      outline: 1px solid #d90416 !important;\n    }\n\n    ${selector} li {\n      outline: 1px solid #d90416 !important;\n    }\n\n    ${selector} dl {\n      outline: 1px solid #fd3427 !important;\n    }\n\n    ${selector} dt {\n      outline: 1px solid #ff0043 !important;\n    }\n\n    ${selector} dd {\n      outline: 1px solid #e80174 !important;\n    }\n\n    ${selector} figure {\n      outline: 1px solid #ff00bb !important;\n    }\n\n    ${selector} figcaption {\n      outline: 1px solid #bf0032 !important;\n    }\n\n    ${selector} table {\n      outline: 1px solid #00cc99 !important;\n    }\n\n    ${selector} caption {\n      outline: 1px solid #37ffc4 !important;\n    }\n\n    ${selector} thead {\n      outline: 1px solid #98daca !important;\n    }\n\n    ${selector} tbody {\n      outline: 1px solid #64a7a0 !important;\n    }\n\n    ${selector} tfoot {\n      outline: 1px solid #22746b !important;\n    }\n\n    ${selector} tr {\n      outline: 1px solid #86c0b2 !important;\n    }\n\n    ${selector} th {\n      outline: 1px solid #a1e7d6 !important;\n    }\n\n    ${selector} td {\n      outline: 1px solid #3f5a54 !important;\n    }\n\n    ${selector} col {\n      outline: 1px solid #6c9a8f !important;\n    }\n\n    ${selector} colgroup {\n      outline: 1px solid #6c9a9d !important;\n    }\n\n    ${selector} button {\n      outline: 1px solid #da8301 !important;\n    }\n\n    ${selector} datalist {\n      outline: 1px solid #c06000 !important;\n    }\n\n    ${selector} fieldset {\n      outline: 1px solid #d95100 !important;\n    }\n\n    ${selector} form {\n      outline: 1px solid #d23600 !important;\n    }\n\n    ${selector} input {\n      outline: 1px solid #fca600 !important;\n    }\n\n    ${selector} keygen {\n      outline: 1px solid #b31e00 !important;\n    }\n\n    ${selector} label {\n      outline: 1px solid #ee8900 !important;\n    }\n\n    ${selector} legend {\n      outline: 1px solid #de6d00 !important;\n    }\n\n    ${selector} meter {\n      outline: 1px solid #e8630c !important;\n    }\n\n    ${selector} optgroup {\n      outline: 1px solid #b33600 !important;\n    }\n\n    ${selector} option {\n      outline: 1px solid #ff8a00 !important;\n    }\n\n    ${selector} output {\n      outline: 1px solid #ff9619 !important;\n    }\n\n    ${selector} progress {\n      outline: 1px solid #e57c00 !important;\n    }\n\n    ${selector} select {\n      outline: 1px solid #e26e0f !important;\n    }\n\n    ${selector} textarea {\n      outline: 1px solid #cc5400 !important;\n    }\n\n    ${selector} details {\n      outline: 1px solid #33848f !important;\n    }\n\n    ${selector} summary {\n      outline: 1px solid #60a1a6 !important;\n    }\n\n    ${selector} command {\n      outline: 1px solid #438da1 !important;\n    }\n\n    ${selector} menu {\n      outline: 1px solid #449da6 !important;\n    }\n\n    ${selector} del {\n      outline: 1px solid #bf0000 !important;\n    }\n\n    ${selector} ins {\n      outline: 1px solid #400000 !important;\n    }\n\n    ${selector} img {\n      outline: 1px solid #22746b !important;\n    }\n\n    ${selector} iframe {\n      outline: 1px solid #64a7a0 !important;\n    }\n\n    ${selector} embed {\n      outline: 1px solid #98daca !important;\n    }\n\n    ${selector} object {\n      outline: 1px solid #00cc99 !important;\n    }\n\n    ${selector} param {\n      outline: 1px solid #37ffc4 !important;\n    }\n\n    ${selector} video {\n      outline: 1px solid #6ee866 !important;\n    }\n\n    ${selector} audio {\n      outline: 1px solid #027353 !important;\n    }\n\n    ${selector} source {\n      outline: 1px solid #012426 !important;\n    }\n\n    ${selector} canvas {\n      outline: 1px solid #a2f570 !important;\n    }\n\n    ${selector} track {\n      outline: 1px solid #59a600 !important;\n    }\n\n    ${selector} map {\n      outline: 1px solid #7be500 !important;\n    }\n\n    ${selector} area {\n      outline: 1px solid #305900 !important;\n    }\n\n    ${selector} a {\n      outline: 1px solid #ff62ab !important;\n    }\n\n    ${selector} em {\n      outline: 1px solid #800b41 !important;\n    }\n\n    ${selector} strong {\n      outline: 1px solid #ff1583 !important;\n    }\n\n    ${selector} i {\n      outline: 1px solid #803156 !important;\n    }\n\n    ${selector} b {\n      outline: 1px solid #cc1169 !important;\n    }\n\n    ${selector} u {\n      outline: 1px solid #ff0430 !important;\n    }\n\n    ${selector} s {\n      outline: 1px solid #f805e3 !important;\n    }\n\n    ${selector} small {\n      outline: 1px solid #d107b2 !important;\n    }\n\n    ${selector} abbr {\n      outline: 1px solid #4a0263 !important;\n    }\n\n    ${selector} q {\n      outline: 1px solid #240018 !important;\n    }\n\n    ${selector} cite {\n      outline: 1px solid #64003c !important;\n    }\n\n    ${selector} dfn {\n      outline: 1px solid #b4005a !important;\n    }\n\n    ${selector} sub {\n      outline: 1px solid #dba0c8 !important;\n    }\n\n    ${selector} sup {\n      outline: 1px solid #cc0256 !important;\n    }\n\n    ${selector} time {\n      outline: 1px solid #d6606d !important;\n    }\n\n    ${selector} code {\n      outline: 1px solid #e04251 !important;\n    }\n\n    ${selector} kbd {\n      outline: 1px solid #5e001f !important;\n    }\n\n    ${selector} samp {\n      outline: 1px solid #9c0033 !important;\n    }\n\n    ${selector} var {\n      outline: 1px solid #d90047 !important;\n    }\n\n    ${selector} mark {\n      outline: 1px solid #ff0053 !important;\n    }\n\n    ${selector} bdi {\n      outline: 1px solid #bf3668 !important;\n    }\n\n    ${selector} bdo {\n      outline: 1px solid #6f1400 !important;\n    }\n\n    ${selector} ruby {\n      outline: 1px solid #ff7b93 !important;\n    }\n\n    ${selector} rt {\n      outline: 1px solid #ff2f54 !important;\n    }\n\n    ${selector} rp {\n      outline: 1px solid #803e49 !important;\n    }\n\n    ${selector} span {\n      outline: 1px solid #cc2643 !important;\n    }\n\n    ${selector} br {\n      outline: 1px solid #db687d !important;\n    }\n\n    ${selector} wbr {\n      outline: 1px solid #db175b !important;\n    }`;\n}\n\n// src/outline/withOutline.ts\nvar withOutline = (StoryFn, context) => {\n  let globals = context.globals || {}, isActive = [!0, \"true\"].includes(globals[PARAM_KEY4]), isInDocs = context.viewMode === \"docs\", outlineStyles = useMemo(() => outlineCSS(isInDocs ? '[data-story-block=\"true\"]' : \".sb-show-main\"), [context]);\n  return useEffect3(() => {\n    let selectorId = isInDocs ? `addon-outline-docs-${context.id}` : \"addon-outline\";\n    return isActive ? addOutlineStyles(selectorId, outlineStyles) : clearStyles2(selectorId), () => {\n      clearStyles2(selectorId);\n    };\n  }, [isActive, outlineStyles, context]), StoryFn();\n};\n\n// src/outline/preview.ts\nvar decorators3 = globalThis.FEATURES?.outline ? [withOutline] : [], initialGlobals3 = {\n  [PARAM_KEY4]: !1\n}, preview_default6 = () => definePreviewAddon7({ decorators: decorators3, initialGlobals: initialGlobals3 });\n\n// src/test/preview.ts\nimport { definePreviewAddon as definePreviewAddon8 } from \"storybook/internal/csf\";\nimport { instrument as instrument2 } from \"storybook/internal/instrumenter\";\nimport {\n  clearAllMocks,\n  fn,\n  isMockFunction,\n  resetAllMocks,\n  restoreAllMocks,\n  uninstrumentedUserEvent,\n  within\n} from \"storybook/test\";\nvar resetAllMocksLoader = ({ parameters: parameters2 }) => {\n  parameters2?.test?.mockReset === !0 ? resetAllMocks() : parameters2?.test?.clearMocks === !0 ? clearAllMocks() : parameters2?.test?.restoreMocks !== !1 && restoreAllMocks();\n}, traverseArgs = (value, depth = 0, key) => {\n  if (depth > 5 || value == null)\n    return value;\n  if (isMockFunction(value))\n    return key && value.mockName(key), value;\n  if (typeof value == \"function\" && \"isAction\" in value && value.isAction && !(\"implicit\" in value && value.implicit)) {\n    let mock = fn(value);\n    return key && mock.mockName(key), mock;\n  }\n  if (Array.isArray(value)) {\n    depth++;\n    for (let i = 0; i < value.length; i++)\n      Object.getOwnPropertyDescriptor(value, i)?.writable && (value[i] = traverseArgs(value[i], depth));\n    return value;\n  }\n  if (typeof value == \"object\" && value.constructor === Object) {\n    depth++;\n    for (let [k, v] of Object.entries(value))\n      Object.getOwnPropertyDescriptor(value, k)?.writable && (value[k] = traverseArgs(v, depth, k));\n    return value;\n  }\n  return value;\n}, nameSpiesAndWrapActionsInSpies = ({ initialArgs }) => {\n  traverseArgs(initialArgs);\n}, patchedFocus = !1, enhanceContext = async (context) => {\n  globalThis.HTMLElement && context.canvasElement instanceof globalThis.HTMLElement && (context.canvas = within(context.canvasElement));\n  try {\n    let clipboard = globalThis.window?.navigator?.clipboard;\n    if (clipboard && (context.userEvent = instrument2(\n      { userEvent: uninstrumentedUserEvent.setup() },\n      {\n        intercept: !0,\n        getKeys: (obj) => Object.keys(obj).filter((key) => key !== \"eventWrapper\")\n      }\n    ).userEvent, Object.defineProperty(globalThis.window.navigator, \"clipboard\", {\n      get: () => clipboard,\n      configurable: !0\n    }), !patchedFocus)) {\n      let originalFocus = HTMLElement.prototype.focus, currentFocus = HTMLElement.prototype.focus, focusingElements = /* @__PURE__ */ new Set();\n      Object.defineProperties(HTMLElement.prototype, {\n        focus: {\n          configurable: !0,\n          set: (newFocus) => {\n            currentFocus = newFocus;\n          },\n          get() {\n            return focusingElements.has(this) ? originalFocus : (focusingElements.add(this), setTimeout(() => focusingElements.delete(this), 0), currentFocus);\n          }\n        }\n      }), patchedFocus = !0;\n    }\n  } catch {\n  }\n}, preview_default7 = () => definePreviewAddon8({\n  loaders: [resetAllMocksLoader, nameSpiesAndWrapActionsInSpies, enhanceContext]\n});\n\n// src/viewport/preview.ts\nimport { definePreviewAddon as definePreviewAddon9 } from \"storybook/internal/csf\";\nvar initialGlobals4 = {\n  [PARAM_KEY]: { value: void 0, isRotated: !1 }\n}, preview_default8 = () => definePreviewAddon9({\n  initialGlobals: initialGlobals4\n});\n\n// src/csf/core-annotations.ts\nfunction getCoreAnnotations() {\n  return [\n    // @ts-expect-error CJS fallback\n    (preview_default5.default ?? preview_default5)(),\n    // @ts-expect-error CJS fallback\n    (preview_default2.default ?? preview_default2)(),\n    // @ts-expect-error CJS fallback\n    (preview_default4.default ?? preview_default4)(),\n    // @ts-expect-error CJS fallback\n    (preview_default6.default ?? preview_default6)(),\n    // @ts-expect-error CJS fallback\n    (preview_default8.default ?? preview_default8)(),\n    // @ts-expect-error CJS fallback\n    (preview_default.default ?? preview_default)(),\n    // @ts-expect-error CJS fallback\n    (preview_default3.default ?? preview_default3)(),\n    // @ts-expect-error CJS fallback\n    (preview_default7.default ?? preview_default7)(),\n    // @ts-expect-error CJS fallback\n    (test_annotations_default.default ?? test_annotations_default)()\n  ];\n}\n\n// src/csf/csf-factories.ts\nfunction definePreview(input) {\n  let composed, preview = {\n    _tag: \"Preview\",\n    input,\n    get composed() {\n      if (composed)\n        return composed;\n      let { addons: addons2, ...rest } = input;\n      return composed = normalizeProjectAnnotations(\n        composeConfigs([...getCoreAnnotations(), ...addons2 ?? [], rest])\n      ), composed;\n    },\n    type() {\n      return this;\n    },\n    meta(meta) {\n      return defineMeta(meta, this);\n    }\n  };\n  return globalThis.globalProjectAnnotations = preview.composed, preview;\n}\nfunction definePreviewAddon10(preview) {\n  return preview;\n}\nfunction isPreview(input) {\n  return input != null && typeof input == \"object\" && \"_tag\" in input && input?._tag === \"Preview\";\n}\nfunction isMeta(input) {\n  return input != null && typeof input == \"object\" && \"_tag\" in input && input?._tag === \"Meta\";\n}\nfunction defineMeta(input, preview) {\n  return {\n    _tag: \"Meta\",\n    input: { ...input, parameters: { ...input.parameters, csfFactory: !0 } },\n    preview,\n    // @ts-expect-error hard\n    story(story = {}) {\n      return defineStory(typeof story == \"function\" ? { render: story } : story, this);\n    }\n  };\n}\nfunction isStory(input) {\n  return input != null && typeof input == \"object\" && \"_tag\" in input && input?._tag === \"Story\";\n}\nfunction defineStory(input, meta) {\n  let composed, compose = () => (composed || (composed = composeStory(\n    input,\n    meta.input,\n    void 0,\n    meta.preview.composed\n  )), composed), __children = [];\n  return {\n    _tag: \"Story\",\n    input,\n    meta,\n    // @ts-expect-error this is a private property used only once in renderers/react/src/preview\n    __compose: compose,\n    __children,\n    get composed() {\n      let composed2 = compose(), { args, argTypes, parameters: parameters2, id, tags, globals, storyName: name } = composed2;\n      return { args, argTypes, parameters: parameters2, id, tags, name, globals };\n    },\n    get play() {\n      return input.play ?? meta.input?.play ?? (async () => {\n      });\n    },\n    async run(context) {\n      await compose().run(context);\n    },\n    test(name, overridesOrTestFn, testFn) {\n      let annotations = typeof overridesOrTestFn != \"function\" ? overridesOrTestFn : {}, testFunction = typeof overridesOrTestFn != \"function\" ? testFn : overridesOrTestFn, play = mountDestructured(this.play) || mountDestructured(testFunction) ? (\n        // mount needs to be explicitly destructured\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        async ({ mount, context }) => {\n          await this.play?.(context), await testFunction(context);\n        }\n      ) : async (context) => {\n        await this.play?.(context), await testFunction(context);\n      }, test = this.extend({\n        ...annotations,\n        name,\n        tags: [Tag.TEST_FN, `!${Tag.AUTODOCS}`, ...annotations.tags ?? []],\n        play\n      });\n      return __children.push(test), test;\n    },\n    extend(input2) {\n      return defineStory(\n        {\n          ...this.input,\n          ...input2,\n          args: { ...this.input.args || {}, ...input2.args },\n          argTypes: combineParameters(this.input.argTypes, input2.argTypes),\n          afterEach: [\n            ...normalizeArrays(this.input?.afterEach ?? []),\n            ...normalizeArrays(input2.afterEach ?? [])\n          ],\n          beforeEach: [\n            ...normalizeArrays(this.input?.beforeEach ?? []),\n            ...normalizeArrays(input2.beforeEach ?? [])\n          ],\n          decorators: [\n            ...normalizeArrays(this.input?.decorators ?? []),\n            ...normalizeArrays(input2.decorators ?? [])\n          ],\n          globals: { ...this.input.globals, ...input2.globals },\n          loaders: [\n            ...normalizeArrays(this.input?.loaders ?? []),\n            ...normalizeArrays(input2.loaders ?? [])\n          ],\n          parameters: combineParameters(this.input.parameters, input2.parameters),\n          tags: combineTags(...this.input.tags ?? [], ...input2.tags ?? [])\n        },\n        this.meta\n      );\n    }\n  };\n}\nfunction getStoryChildren(story) {\n  return \"__children\" in story ? story.__children : [];\n}\n\n// src/csf/index.ts\nvar sanitize = (string) => string.toLowerCase().replace(/[ '`~!@#$%^&*()_|+\\-=?;:'\",.<>\\{\\}\\[\\]\\\\\\/]/gi, \"-\").replace(/-+/g, \"-\").replace(/^-+/, \"\").replace(/-+$/, \"\"), sanitizeSafe = (string, part) => {\n  let sanitized = sanitize(string);\n  if (sanitized === \"\")\n    throw new Error(`Invalid ${part} '${string}', must include alphanumeric characters`);\n  return sanitized;\n}, toId = (kind, name) => `${sanitizeSafe(kind, \"kind\")}${name ? `--${sanitizeSafe(name, \"name\")}` : \"\"}`, toTestId = (parentId, testName) => `${parentId}:${sanitizeSafe(testName, \"test\")}`, storyNameFromExport = (key) => toStartCaseStr(key);\nfunction matches(storyKey, arrayOrRegex) {\n  return Array.isArray(arrayOrRegex) ? arrayOrRegex.includes(storyKey) : storyKey.match(arrayOrRegex);\n}\nfunction isExportStory(key, { includeStories, excludeStories }) {\n  return (\n    // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs\n    key !== \"__esModule\" && (!includeStories || matches(key, includeStories)) && (!excludeStories || !matches(key, excludeStories))\n  );\n}\nvar parseKind = (kind, { rootSeparator, groupSeparator }) => {\n  let [root, remainder] = kind.split(rootSeparator, 2), groups = (remainder || kind).split(groupSeparator).filter((i) => !!i);\n  return {\n    root: remainder ? root : null,\n    groups\n  };\n}, combineTags2 = (...tags) => {\n  let result = tags.reduce((acc, tag) => (tag.startsWith(\"!\") ? acc.delete(tag.slice(1)) : acc.add(tag), acc), /* @__PURE__ */ new Set());\n  return Array.from(result);\n};\nexport {\n  combineTags2 as combineTags,\n  definePreview,\n  definePreviewAddon10 as definePreviewAddon,\n  getCoreAnnotations,\n  getStoryChildren,\n  includeConditionalArg,\n  isExportStory,\n  isMeta,\n  isPreview,\n  isStory,\n  parseKind,\n  sanitize,\n  storyNameFromExport,\n  toId,\n  toTestId\n};\n"],"names":[],"sourceRoot":""}